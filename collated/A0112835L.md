# A0112835L
###### /src/constant/CommandType.java
``` java
 *
 */
public enum CommandType {
	ADD, DELETE, EDIT, SELECT, UNDO, RESERVE, CONFIRM, COMPLETE, CHANGETAB, INVALID, IMPORT, EXPORT;
}
```
###### /src/parser/DateChecker.java
``` java
 *
 */
public class DateChecker {

	public static boolean isDay = false;
	
	private static final String TOM = "tom";
	private static final String TOD = "tod";
	private static final String MON = "mon";
	private static final String TUE = "tue";
	private static final String WED = "wed";
	private static final String THU = "thu";
	private static final String FRI = "fri";
	private static final String SAT = "sat";
	private static final String SUN = "sun";

	private static final int SUNDAY = 1;
	private static final int MONDAY = 2;
	private static final int TUESDAY = 3;
	private static final int WEDNESDAY = 4;
	private static final int THURSDAY = 5;
	private static final int FRIDAY = 6;
	private static final int SATURDAY = 7;
	private static final int DAYS_IN_WEEK = 7;

	private static ArrayList<SimpleDateFormat> supportedDateFormats;
	private static ArrayList<SimpleDateFormat> supportedTimeFormats;
	private static ArrayList<SimpleDateFormat> specificDateFormats;
	
	private static Calendar calendar;
	private static Date dateToday;
	private static int intToday;
	
	private static Logger Log = Logger.getLogger("DATECHECKER");

	/**
	 * Check whether the passed date is of the accepted format
	 * @param stringDateInput
	 * @return the converted Date if the passed date is Day of the week format, otherwise just the date with no conversion
	 */
	public static Date validateDate(String stringDateInput){		
		Date inputDate = null;
	
		Initialization();
		
		inputDate = parseInputDate(stringDateInput);
		//inputDate = parseInputTime(stringDateInput);
		isDay = false;
		
		if (inputDate == null) {
			inputDate = convertDayToDate(stringDateInput);
			isDay = true;
		}
		
		return inputDate;
	}
	
	/**
	 * check whether the passed date is of the accepted time
	 * @param stringTimeInput
	 * @return date
	 */
	public static Date validateTime(String stringTimeInput){
		Date inputTime = null;
		
		Initialization();
		
		inputTime = parseInputTime(stringTimeInput);
		
		return inputTime;
	}

	/**
	 * check whether the passed date is of the accepted specific date
	 * @param stringDateInput
	 * @return date
	 */
	public static Date validateSpecificDate(String stringDateInput){
		Date inputDate = null;
		
		Initialization();
		
		inputDate = parseSpecificDate(stringDateInput);
		
		return inputDate;
	}
		
	
	private static Date parseSpecificDate(String stringDateInput){
		Date inputDate = null;
		for(SimpleDateFormat format : specificDateFormats){
			format.setLenient(false);
			
			try {
				inputDate = format.parse(stringDateInput);
			} catch (ParseException e) {
				//System.out.println(e.toString());
			}
		}
		return inputDate;
	}
	
	private static Date parseInputDate(String stringDateInput){
		Date inputDate = null;
		for (SimpleDateFormat format : supportedDateFormats){
			format.setLenient(false);
			try {
				inputDate = format.parse(stringDateInput);
				break;
			} catch (ParseException e) {
				//System.out.println(e.toString());
			}
		}

		return inputDate;
	}
	
	private static Date parseInputTime(String stringTimeInput){
		Date inputTime = null;
		for(SimpleDateFormat format : supportedTimeFormats){
			format.setLenient(false);
			try {
				inputTime = format.parse(stringTimeInput);
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				//e.printStackTrace();
			}
		}
		return inputTime;
	}

	private static void Initialization(){
		calendar = Calendar.getInstance();
		dateToday = new Date();
		calendar.setTime(dateToday);
		intToday = calendar.get(Calendar.DAY_OF_WEEK);

		supportedDateFormats = new ArrayList<>();
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yy HH:mm:ss"));
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yy HH:mm"));		
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yyyy HH:mm"));	
		supportedDateFormats.add(new SimpleDateFormat("dd MMM yy HH:mm"));
		supportedDateFormats.add(new SimpleDateFormat("dd MMM yyyy HH:mm"));
		supportedDateFormats.add(new SimpleDateFormat("HH:mm dd/MM/yy"));		
		supportedDateFormats.add(new SimpleDateFormat("HH:mm dd MMM yy"));
		supportedDateFormats.add(new SimpleDateFormat("HH:mm dd/MM/yyyy"));		
		supportedDateFormats.add(new SimpleDateFormat("HH:mm dd MMM yyyy"));
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yy hh:mm a"));
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yy hh a"));
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yyyy hh:mm a"));
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yyyy hh a"));
		supportedDateFormats.add(new SimpleDateFormat("dd MMM yy hh:mm a"));
		supportedDateFormats.add(new SimpleDateFormat("dd MMM yy hh a"));
		supportedDateFormats.add(new SimpleDateFormat("dd MMM yyyy hh:mm a"));
		supportedDateFormats.add(new SimpleDateFormat("dd MMM yyyy hh a"));
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yy"));
		supportedDateFormats.add(new SimpleDateFormat("dd/MM/yyyy"));
		supportedDateFormats.add(new SimpleDateFormat("dd MMM yy"));
		supportedDateFormats.add(new SimpleDateFormat("dd MMM yyyy"));


		supportedTimeFormats = new ArrayList<>();
		supportedTimeFormats.add(new SimpleDateFormat("hh:mm a"));
		supportedTimeFormats.add(new SimpleDateFormat("hh a"));
		supportedTimeFormats.add(new SimpleDateFormat("HH:mm"));
		supportedTimeFormats.add(new SimpleDateFormat("HH"));
		
		specificDateFormats = new ArrayList<>();
		specificDateFormats.add(new SimpleDateFormat("dd/MM/yy"));
		specificDateFormats.add(new SimpleDateFormat("dd/MM/yyyy"));
		specificDateFormats.add(new SimpleDateFormat("dd MMM yy"));
		specificDateFormats.add(new SimpleDateFormat("dd MMM yyyy"));
	}


	public static Date convertNextWeekDayToDate(String stringDateInput){
		int beginIndex = 0;
		int endIndex = 3;
		int interval;

		Initialization();
		
		String dayAbbreviation = stringDateInput.substring(beginIndex, endIndex);
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yy");
		String stringToday = dateFormat.format(dateToday);
		
		Date todayDate = null;

		try {
			todayDate = dateFormat.parse(stringToday);
		} catch (ParseException e) {
			
		}
		
		if(dayAbbreviation.equalsIgnoreCase(SUN)){
			if(intToday == SUNDAY){
				interval = (SUNDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			} else if(intToday < SUNDAY){
				interval = (SUNDAY - intToday) + DAYS_IN_WEEK;
				return findDate(interval);
			} else{
				interval = (intToday - SUNDAY) + DAYS_IN_WEEK;
				return findDate(interval);
			}
		}  else if(dayAbbreviation.equalsIgnoreCase(MON)){
			if(intToday == MONDAY){
				interval = (MONDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			} else if(intToday < MONDAY){
				interval = (MONDAY - intToday) + DAYS_IN_WEEK;
				return findDate(interval);
			} else{
				interval = (intToday - MONDAY) + DAYS_IN_WEEK;
				return findDate(interval);
			}
		} else if(dayAbbreviation.equalsIgnoreCase(TUE)){
			if(intToday == TUESDAY){
				interval = (TUESDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			} else if(intToday < TUESDAY){
				interval = (TUESDAY - intToday) + DAYS_IN_WEEK;
				return findDate(interval);
			} else{
				interval = (intToday - TUESDAY) + DAYS_IN_WEEK;
				return findDate(interval);
			}
		} else if(dayAbbreviation.equalsIgnoreCase(WED)){
			if(intToday == WEDNESDAY){
				interval = (WEDNESDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			} else if(intToday < WEDNESDAY){
				interval = (WEDNESDAY - intToday) + DAYS_IN_WEEK;
				return findDate(interval);
			} else{
				interval = (intToday - WEDNESDAY) + DAYS_IN_WEEK;
				return findDate(interval);
			}
		} else if(dayAbbreviation.equalsIgnoreCase(THU)){
			if(intToday == THURSDAY){
				interval = (THURSDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			} else if(intToday < THURSDAY){
				interval = (THURSDAY - intToday) + DAYS_IN_WEEK;
				return findDate(interval);
			} else{
				interval = (intToday - THURSDAY) + DAYS_IN_WEEK;
				return findDate(interval);
			}
		} else if(dayAbbreviation.equalsIgnoreCase(FRI)){
			if(intToday == FRIDAY){
				interval = (FRIDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			} else if(intToday < FRIDAY){
				interval = (FRIDAY - intToday) + DAYS_IN_WEEK;
				return findDate(interval);
			} else{
				interval = (intToday - FRIDAY) + DAYS_IN_WEEK;
				return findDate(interval);
			}
		} else if(dayAbbreviation.equalsIgnoreCase(SAT)){
			if(intToday == SATURDAY){
				interval = (SATURDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			} else if(intToday < SATURDAY){
				interval = (SATURDAY - intToday) + DAYS_IN_WEEK;
				return findDate(interval);
			} else{
				interval = (intToday - SATURDAY) + DAYS_IN_WEEK;
				return findDate(interval);
			}
		}
		
		return null;
	}
	/**
	 * Convert day of the week to dd/MM/yyyy format 
	 * @param stringDateInput
	 * @return
	 */
	public static Date convertDayToDate(String stringDateInput){
		int beginIndex = 0;
		int endIndex = 3;
		Initialization();
		
		String dayAbbreviation = stringDateInput.substring(beginIndex, endIndex);
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yy");
		String stringToday = dateFormat.format(dateToday);

		Date todayDate = null;
		try {
			todayDate = dateFormat.parse(stringToday);
		} catch (ParseException e) {

		}
		if (dayAbbreviation.equalsIgnoreCase(SUN)){
			int interval;
			if(intToday == SUNDAY){
				return todayDate;
			}else if (intToday < SUNDAY) {
				interval = SUNDAY - intToday;
				return findDate(interval);
			}else{
				interval = (SUNDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			}

		}else if (dayAbbreviation.equalsIgnoreCase(MON)){
			int interval;
			if(intToday == MONDAY){
				return todayDate;
			}else if(intToday < MONDAY){
				interval = MONDAY - intToday;
				return findDate(interval);
			}else{
				interval = (MONDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			}
		}else if (dayAbbreviation.equalsIgnoreCase(TUE)){
			int interval;
			if(intToday == TUESDAY){
				return todayDate;
			}else if(intToday < TUESDAY){
				interval = TUESDAY - intToday;
				return findDate(interval);
			}else{
				interval = (TUESDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			}
		}else if (dayAbbreviation.equalsIgnoreCase(WED)){
			int interval;
			if(intToday == WEDNESDAY){
				return todayDate;
			}else if(intToday < WEDNESDAY){
				interval = WEDNESDAY - intToday;
				return findDate(interval);
			}else{
				interval = (WEDNESDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			}
		}else if (dayAbbreviation.equalsIgnoreCase(THU)){
			int interval;
			if(intToday == THURSDAY){
				return todayDate;

			}else if(intToday < THURSDAY){
				interval = THURSDAY - intToday;
				return findDate(interval);
			}else{
				interval = (THURSDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			}

		}else if (dayAbbreviation.equalsIgnoreCase(FRI)){
			int interval;
			if(intToday == FRIDAY){
				return todayDate;

			}else if(intToday < FRIDAY){
				interval = FRIDAY - intToday;
				return findDate(interval);
			}else{
				interval = (FRIDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			}

		}else if (dayAbbreviation.equalsIgnoreCase(SAT)){
			int interval;
			if(intToday == SATURDAY){
				return todayDate;

			}else if(intToday < SATURDAY){
				interval = SATURDAY - intToday;
				return findDate(interval);
			}else{
				interval = (SATURDAY + DAYS_IN_WEEK) - intToday;
				return findDate(interval);
			}
		}
		return null;
	}

	/**
	 * 
	 * @param interval - from the current date to the date the user wnat to set
	 * @return converted Date
	 */
	public static Date findDate(int interval){
		Initialization();

		calendar.add(Calendar.DATE, interval);
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yy");
		String newDate = dateFormat.format(calendar.getTime());
		return (parseInputDate(newDate));
	}
	
	
	/**
	 * This method replaces the hour and minutes of the DateTime with the specified time
	 * @param date
	 * @param setTime 
	 * @return
	 */
	public static Date writeTime(String date, String setTime){
		if(setTime == null){
			return null;
		}
		Format formatter = new SimpleDateFormat("dd/MM/yy HH:mm");
		date = formatter.format(validateDate(date));
		if(date.indexOf("00:00") >= 0){
			date = date.replace("00:00", setTime);
		} else if(date.indexOf("23:59") >= 0){
			date = date.replace("23:59", setTime);
		}
		return (validateDate(date));
	}
	
	/**
	 * Converts time which is in AM or PM format to 24 hour time format
	 * @param timeInput
	 * @return time in 24 hour format e.g. 23:59
	 */
	public static String convertAmPmToTime(String timeInput){
		SimpleDateFormat formatterInput;
		SimpleDateFormat formatterOutput = new SimpleDateFormat("HH:mm");
		String time = null;
		try {
			formatterInput = new SimpleDateFormat("hh a");
			time = formatterOutput.format(formatterInput.parse(timeInput));
			return time;
		} catch (ParseException e) {
			//System.out.println(e.toString());
		}

		try{
			formatterInput = new SimpleDateFormat("hh:mm a");
			time = formatterOutput.format(formatterInput.parse(timeInput));
			return time;
		} catch (ParseException e){
			//System.out.println(e.toString());
		}
		
		try{
			formatterInput = new SimpleDateFormat("HH:mm");
			time = formatterOutput.format(formatterInput.parse(timeInput));
			return time;
		} catch(ParseException e){
			//System.out.println(e.toString());
		}
		return time;
	}
}
```
###### /src/parser/Parser.java
``` java
 *
 */
public class Parser {

	private static Event oldEvent;
	private static ReservedEvent oldReservedEvent;
	private static GenericEvent oldGenericEvent;
	private static String recordedDate;
	private boolean isNameDefined = true;
	private boolean isAfterOn = false;
	private boolean isAfterNext = false;
	private boolean isEdit = false;
	private final String PATTERN_SPACE = "(\\s)";
	private final String PATTERN_AM_OR_PM = "(\\b(am)\\b|\\b(pm)\\b)";
	private final String PATTERN_AT = "(\\bat\\b)";
	private final String PATTERN_AT_OR_BY_OR_NEXT = "(\\b(at)\\b|\\b(by)\\b|\\b(next)\\b)";
	private final String PATTERN_AT_OR_BY = "(\\b(at)\\b|\\b(by)\\b)";
	private final String PATTERN_COLUMN = "(\\b(:)\\b)";
	private final String PATTERN_AND = "(\\b(and)\\b|\\b(&)\\b)";
	private final String PATTERN_TO = "(\\bto\\b)";
	private final String PATTERN_BEFORE = "(\\bbefore\\b)";
	private final String PATTERN_NEXT = "(\\bnext\\b)";
	private final String PATTERN_AFTER_NEXT = "(\\bafter next\\b)";
	private final String PATTERN_TODAY = "(\\btoday\\b)";
	private final String PATTERN_TOMORROW = "(\\btomorrow\\b)";
	private final String PATTERN_TOD = "(\\btod\\b)";
	private final String PATTERN_TMR = "(\\btmr\\b)";
	private final String PATTERN_PREP_ALL = "(\\b(on)\\b|\\b(by)\\b|\\b(from)\\b|\\b(at)\\b|\\b(next)\\b|\\b(tomorrow)\\b|\\b(tmr)\\b)";
	private final String PATTERN_KEYWORD_ALL = "(\\b(starttime)\\b|\\b(startdate)\\b|\\b(endtime)\\b|\\b(enddate)\\b|\\b(location)\\b|\\b(note)\\b)";
	
	private final String PREP_ON = "on";
	private final String PREP_AT = "at";
	private final String PREP_BY = "by";
	private final String PREP_FROM = "from";
	private final String PREP_NEXT = "next";
	private final String PREP_TMR = "tmr";
	private final String PREP_TOMORROW = "tomorrow";

	private final String KEY_START_TIME = "starttime";
	private final String KEY_START_DATE = "startdate";
	private final String KEY_END_TIME = "endtime";
	private final String KEY_END_DATE = "enddate";
	private final String KEY_NOTE = "note";
	private final String KEY_LOCATION = "location";

	private final String TIME_BEFORE_MIDNIGHT = "23:59";
	private final String TIME_BEFORE_MIDNIGHT_SEC = "23:59:01";
	private final String TIME_MIDNIGHT = "00:00";
	private final String ERROR_DATE_FORMAT = "The input date format is not supported";

	private final String TAB_UNDETERMINED = "UNDETERMINE";
	private final String TAB_COMPLETED = "COMPLETE";
	private final String TAB_INCOMPLETE = "INCOMPLETE";
	private final int DAYS_IN_WEEK = 7;

	public Command parseCommand(String input){
		Command cmdInterface = null;
		String command = getFirstWord(input);
		CommandType tempCmd = getCommandType(command);

		if (tempCmd == CommandType.INVALID){
			Event event = new Event();
			event = null;
			oldGenericEvent = null;
		} else if(tempCmd == CommandType.ADD){
			Event event = new Event();
			GenericEvent task = decodeAddData(event, removeFirstWord(input));
			
			if(task == null){
				oldGenericEvent = null;
			} else if(task.getStatus() == Status.UNDETERMINED){
				oldGenericEvent = (ReservedEvent) task;
				cmdInterface = new Add(task);
			} else {
				if(((Event) task).getEndTime() == Constant.MAX_DATE){
					oldGenericEvent = null;
					cmdInterface = null;
				} else{
					oldGenericEvent = (Event) task;
					cmdInterface = new Add(task);
				}
			}	
		} else if(tempCmd == CommandType.DELETE){
			Event event = new Event();
			event = decodeDeleteData(event, removeFirstWord(input));
			oldGenericEvent = null;
			cmdInterface = new Delete(event);
		} else if(tempCmd == CommandType.EDIT){
			isEdit = true;
			Event event = new Event();
			Event newEvent = new Event();
			if(oldGenericEvent instanceof Event){	/*to edit the previously added event which is selected automatically*/
				cloneEvent((Event) oldGenericEvent, event);
				event = decodeEditData(event, removeFirstWord(input));
			
				oldGenericEvent = (Event) event;
				cmdInterface = new Edit(event);
			} else if(oldGenericEvent instanceof ReservedEvent){ /*to edit the previously reserved event which is selected automatically*/
				ArrayList<TimePair> reservedTimes = new ArrayList<>();
				cloneReservedEvent((ReservedEvent)oldGenericEvent, event);
				cloneReservedTimePair(reservedTimes, (ReservedEvent) oldGenericEvent);

				GenericEvent genericEvent = decodeEditReservedData(event, reservedTimes, removeFirstWord(input));			
				oldGenericEvent = genericEvent;
				cmdInterface = new Edit(genericEvent);
			} else{				/*to edit the selected events*/
				event = decodeEditData(event, removeFirstWord(input));
				cmdInterface = new Edit(event);
			}
		} else if(tempCmd == CommandType.SELECT){		
			Event event = new Event();
			event = decodeSelectData(event, removeFirstWord(input));
			oldGenericEvent = null;
			if(event == null){
				cmdInterface = null;
			}else if(event.getSelection().isEmpty()){
				cmdInterface = new Select(event);
			} else{
				cmdInterface = new Select(event.getSelection().get(0));
			}
		} else if(tempCmd == CommandType.RESERVE){
			Event event = new Event();
			ReservedEvent reserved = new ReservedEvent();
			reserved = decodeReservedData(event, removeFirstWord(input));
			if(reserved != null){
				oldGenericEvent = reserved;
				cmdInterface = new Reserve (reserved);
			}
		} else if(tempCmd == CommandType.UNDO){
			Event event = new Event();
			cmdInterface = new Undo();
		} else if(tempCmd == CommandType.CONFIRM){
			Event event = new Event();
			event = decodeSelectData(event, removeFirstWord(input));
			oldGenericEvent = null;
			if(event.getSelection().isEmpty()){
				cmdInterface = new Confirm(event.getStartTime(), event.getEndTime(), event.getStartTimeString(), event.getEndTimeString());
			} else{
				cmdInterface = new Confirm(event.getSelection().get(0));
			}
		} else if(tempCmd == CommandType.COMPLETE){
			Event event = new Event();
			oldGenericEvent = null;
			cmdInterface = new Complete();
		} else if(tempCmd == CommandType.EXPORT) {
			Event event = new Event();
			event = decodeImportExportData(event, removeFirstWord(input));
			cmdInterface = new Export(event);
		} else if(tempCmd == CommandType.IMPORT) {
			Event event = new Event();
			event = decodeImportExportData(event, removeFirstWord(input));
			cmdInterface = new Import(event);
		} else if(tempCmd == CommandType.CHANGETAB){
			Status tab = decodeChangeTab(removeFirstWord(input));
			cmdInterface = new ChangeTab(tab);
		}
		return cmdInterface;
	}
	
	/**
	 * For testing user input (TEST)
	 * @param input
	 * @return
	 */
	public GenericEvent testingDeterminedStuff(String input){
		String command = getFirstWord(input);
		CommandType tempCmd = getCommandType(command);

		if (tempCmd == CommandType.INVALID){
			return null;
		} else if(tempCmd == CommandType.ADD){
			Event task = new Event();
			decodeAddData(task, removeFirstWord(input));
			oldEvent = task;
			return task;
		} else if(tempCmd == CommandType.DELETE){
			Event task = new Event();
			oldEvent = null;
			return decodeDeleteData(task, removeFirstWord(input));
		} else if(tempCmd == CommandType.EDIT){
			isEdit = true;

			if(oldEvent != null){
				Event event = new Event();
				cloneEvent(oldEvent, (Event) event);
				event = decodeEditData((Event) event, removeFirstWord(input));
				oldEvent = (Event) event;
				return event;

			} else{
				ArrayList<TimePair> reservedTimes = new ArrayList<>();
				Event event = new Event();
				cloneReservedEvent(oldReservedEvent, (Event) event);
				cloneReservedTimePair(reservedTimes, oldReservedEvent);

				GenericEvent genericEvent = decodeEditReservedData((Event) event, reservedTimes, removeFirstWord(input));			

				oldReservedEvent = (ReservedEvent) genericEvent;
				return genericEvent;
			}
		} 
		return null;
	}


	public GenericEvent testingReservedStuff(String input){
		String command = getFirstWord(input);
		CommandType tempCmd = getCommandType(command);
		Event task = new Event();
		if(tempCmd == CommandType.RESERVE){
			ReservedEvent reserved = new ReservedEvent();
			reserved = decodeReservedData(task, removeFirstWord(input));
			oldReservedEvent = reserved;
			oldEvent = null;
			return reserved;
		} else if(tempCmd == CommandType.CONFIRM){
			GenericEvent event = new Event();

		}
		return null;
	}


	/**
	 * clone Event to Event type object
	 * @param eventToBeCloned
	 * @param event
	 * @return the cloned event
	 */
	public void cloneEvent(Event eventToBeCloned, Event event){
		event.setName(eventToBeCloned.getName());
		event.setDescription(eventToBeCloned.getDescription());
		event.setCategory(eventToBeCloned.getCategory());
		event.setEndTime(eventToBeCloned.getEndTime());
		event.setStartTime(eventToBeCloned.getStartTime());
		event.setLocation(eventToBeCloned.getLocation());
		event.setStatus(eventToBeCloned.getStatus());
	}

	/**
	 * clone ReservedEvent to Event type object
	 * @param eventToBeCloned
	 * @param event
	 */
	public void cloneReservedEvent(ReservedEvent eventToBeCloned, Event event){
		event.setName(eventToBeCloned.getName());
		event.setDescription(eventToBeCloned.getDescription());
		event.setCategory(eventToBeCloned.getCategory());
		event.setLocation(eventToBeCloned.getLocation());
		event.setStatus(eventToBeCloned.getStatus());
	}

	/**
	 * clone TimePairs Arraylist from ReservedEvent
	 * @param times
	 * @param reservedEvent
	 */
	public void cloneReservedTimePair(ArrayList<TimePair> times, ReservedEvent reservedEvent){		
		for(int i=0 ; i< reservedEvent.getReservedTimes().size(); i++){
			TimePair time = new TimePair(reservedEvent.getReservedTimes().get(i).getStartTime(),
					reservedEvent.getReservedTimes().get(i).getEndTime());
			times.add(time);
		}
	}


	/**
	 * Decodes the user input for Adding new task
	 * @param task
	 * @param input
	 * @return Event object with updated values
	 */
	private GenericEvent decodeAddData(Event task, String input){
		String remainingInput = extractDescription(task, input);
		task =  determineQuotedInput(task, remainingInput);
		task =  decodeDataFromInput(task, remainingInput);
		isEdit = false;
		if(task == null){
			return task;
		}
		
		if(task.getStatus() == Status.UNDETERMINED){
			ArrayList<TimePair> times = new ArrayList<>();
			TimePair reservedTime = new TimePair(task.getStartTime(),task.getEndTime());
			times.add(reservedTime);
			ReservedEvent reserved = new ReservedEvent(task.getName(), task.getLocation(), task.getDescription(),
					task.getCategory(), times, task.getStatus());

			return reserved;
		}

		return task;
	}

	/**
	 * Decodes the user input for Reserving new task
	 * @param event
	 * @param input
	 * @return reserved event
	 */
	private ReservedEvent decodeReservedData(Event task, String input){
		int startIndex = 0;
		int endIndex = startIndex;
		String name = null;
		ArrayList<String> choppedInputData = new ArrayList<>();
		ArrayList<TimePair> reservedTimes = new ArrayList<>();
		isEdit = false;

		/**extract notes from the input if it is declared**/
		String remainingInput = extractDescription(task, input);

		/**extract location from the input if it is declared**/
		remainingInput = extractLocationFromAt(task, remainingInput);

		/**extract "task name that has preposition on, from, to, by, at" **/
		task = determineQuotedInput(task, remainingInput);

		/**to find conjunction AND in a sentence**/
		Pattern pattern = Pattern.compile(PATTERN_AND,Pattern.CASE_INSENSITIVE);
		Matcher matcher = pattern.matcher(remainingInput);

		while(matcher.find()){
			endIndex = matcher.start();
			choppedInputData.add(remainingInput.substring(startIndex, endIndex).trim());
			startIndex = matcher.end();
		}
		choppedInputData.add(remainingInput.substring(startIndex,remainingInput.length()).trim());

		/**decode all the other information like name, location from input**/
		task = decodeDataFromInput(task, choppedInputData.get(0));
		if(task == null){
			return null;
		} 
		
		TimePair reservedTime = new TimePair(task.getStartTime(),task.getEndTime());
		reservedTimes.add(reservedTime);
		name = task.getName().trim();
		
		/**check if the connected data are date time **/
		for(int i = 1; i < choppedInputData.size(); i++){
			task.setStartTime(Constant.MIN_DATE);
			task.setEndTime(Constant.MAX_DATE);
			task.setName(name);
			isNameDefined = true;
			task = decodeDataFromInput(task, choppedInputData.get(i));

			if(task.getStartTime() == Constant.MIN_DATE && task.getEndTime() == Constant.MAX_DATE){
				name = name + " "+ task.getName().trim();
			} else{
				reservedTime = new TimePair(task.getStartTime(),task.getEndTime());
				reservedTimes.add(reservedTime);
			}
		}
		ReservedEvent reserved = new ReservedEvent(name, task.getLocation(),
				task.getDescription(), task.getCategory(), reservedTimes, GenericEvent.Status.UNDETERMINED);
		return reserved;
	}

	/**
	 * Extract the directory location that the user wants to work with
	 * @param task
	 * @param input
	 * @return event object with directory location in name field
	 */
	private Event decodeImportExportData(Event task, String input){
		if(input.indexOf('\\') >= 0){
			return null;
		} else{
			task.setName(input);
		}
		return task;
	}


	private Status decodeChangeTab(String input){
		input = input.toUpperCase();
		if(input.contains("U")){
			return Constant.TAB_UNDETERMINED;
		} else if(input.contains("C")){
			return Constant.TAB_COMPLETE;
		} else if(input.contains("I")){
			return Constant.TAB_INCOMPLETE;
		}

		return Constant.TAB_INCOMPLETE;
	}

	/**
	 * Decodes the user input for selecting task
	 * @param task
	 * @param input
	 * @return
	 */
	private Event decodeSelectData(Event task, String input){
		int startIndex = 0;
		int endIndex = startIndex;

		List<Integer> indexes = new ArrayList<>();
		int userChoice;
		int i = 0;

		String remainingInput = extractDescription(task, input);

		if(input.indexOf("#") >= 0){
			startIndex = input.indexOf("#",startIndex) + 1;
			while(input.indexOf(",", startIndex) > 0){
				endIndex = input.indexOf(",", startIndex);
				userChoice = Integer.parseInt(input.substring(startIndex, endIndex));
				startIndex = endIndex + 1;
				indexes.add(userChoice);
				if(input.indexOf("#",startIndex) >= 0){
					startIndex = input.indexOf("#",startIndex) + 1;
				}
			} 
			userChoice = Integer.parseInt(input.substring(startIndex));
			indexes.add(userChoice);		
			task.setSelection(indexes);
		} else{
			task = determineQuotedInput(task, remainingInput);
			task = decodeDataFromInput(task, remainingInput);
		}


		return task;
	}

	/**
	 * Decodes the user input for Deleting a task by name
	 * @param task
	 * @param input
	 * @return Event object with updated name field to be checked, other fields are initialized as default values
	 */
	private Event decodeDeleteData(Event task, String input){
		boolean isCategoryDefined = false;
		int startIndex = 0;
		int endIndex = startIndex;

		List<Integer> indexes = new ArrayList<>();
		int userChoice;
		int i = 0;

		String remainingInput = extractDescription(task, input);
		if(remainingInput.isEmpty()){
			return null;
		}

		/** Look for Selecting Category type command **/
		if(input.indexOf("--") >= 0){
			startIndex = input.indexOf("--", startIndex) + 1;
			endIndex = input.length();

			if(classifyCategory(input) == null){
				task.setCategory(null);
				task.setStatus(GenericEvent.Status.NULL);
			} else {
				task.setCategory(classifyCategory(remainingInput));
				isCategoryDefined = true;
			}
			task.setStatus(classifyStatus(remainingInput));
			return task;
		} 

		if(input.indexOf("#") >= 0){
			startIndex = input.indexOf("#",startIndex) + 1;
			while(input.indexOf(",", startIndex) > 0){
				endIndex = input.indexOf(",", startIndex);
				userChoice = Integer.parseInt(input.substring(startIndex, endIndex));
				startIndex = endIndex + 1;
				indexes.add(userChoice);
				if(input.indexOf("#",startIndex) >= 0){
					startIndex = input.indexOf("#",startIndex) + 1;
				}
			} 
			userChoice = Integer.parseInt(input.substring(startIndex));
			indexes.add(userChoice);		
			task.setSelection(indexes);
		} else{
			task = determineQuotedInput(task, remainingInput);
			task = decodeDataFromInput(task, remainingInput);
		}
		return task;
	}



	/**
	 * Decodes the user input for Editing task either by name or date time or location or note
	 * @param task
	 * @param input
	 * @return Event object with updated field of which the user choose to edit, other fields that are not
	 * 			edited remain as initial values
	 */
	private Event decodeEditData(Event task, String input){
		String remainingInput = extractDescription(task, input);
		if(input.isEmpty()){
			return null;
		}
		if(remainingInput.isEmpty()){
			return task;
		}
		task = determineQuotedInput(task, remainingInput);
		return decodeDataFromInput(task, remainingInput);
	}

	private GenericEvent decodeEditReservedData(Event task, ArrayList<TimePair> prevReservedTimes,String input){
		GenericEvent event;
		int startIndex = 0;
		int endIndex = startIndex;		
		String name = null;
		ArrayList<String> choppedInputData = new ArrayList<>();
		ArrayList<TimePair> reservedTimes = new ArrayList<>();

		/**extract notes from the input if it is declared**/
		String remainingInput = extractDescription(task, input);

		if(remainingInput.isEmpty()){
			return null;
		}

		/**extract location from the input if it is declared**/
		remainingInput = extractLocationFromAt(task, remainingInput);

		/**extract "task name that has preposition on, from, to, by, at" **/
		task = determineQuotedInput(task, remainingInput);

		/**to find AND in a sentence**/
		Pattern pattern = Pattern.compile(PATTERN_AND,Pattern.CASE_INSENSITIVE);
		Matcher matcher = pattern.matcher(remainingInput);

		while(matcher.find()){
			endIndex = matcher.start();
			choppedInputData.add(remainingInput.substring(startIndex, endIndex).trim());
			startIndex = matcher.end();
		}
		choppedInputData.add(remainingInput.substring(startIndex,remainingInput.length()).trim());

		/**decode all the other information like name, location from input**/
		task = decodeDataFromInput(task, choppedInputData.get(0));
		TimePair reservedTime = new TimePair(task.getStartTime(),task.getEndTime());
		reservedTimes.add(reservedTime);
		name = task.getName().trim();

		/**check if the connected data are date time **/
		for(int i = 1; i < choppedInputData.size(); i++){
			task.setStartTime(Constant.MIN_DATE);
			task.setEndTime(Constant.MAX_DATE);
			task = decodeDataFromInput(task, choppedInputData.get(i));

			if(task.getStartTime() == Constant.MIN_DATE && task.getEndTime() == Constant.MAX_DATE){
				name = name + " "+ task.getName().trim();
			} else{
				reservedTime = new TimePair(task.getStartTime(),task.getEndTime());
				reservedTimes.add(reservedTime);
			}
		}

		if(reservedTimes.get(0).getStartTime() != Constant.MIN_DATE && reservedTimes.get(0).getEndTime() != Constant.MAX_DATE){
			event = new Event(task.getName(), task.getLocation(), task.getDescription(), task.getCategory(), task.getStartTime(),
					task.getEndTime(), task.getStartTimeString(), task.getEndTimeString(), Status.INCOMPLETE);
		} else if(reservedTimes.get(0).getStartTime() == Constant.MIN_DATE && reservedTimes.get(0).getEndTime() != Constant.MAX_DATE){
			event = new Event(task.getName(), task.getLocation(), task.getDescription(), task.getCategory(), task.getStartTime(),
					task.getEndTime(), task.getStartTimeString(), task.getEndTimeString(), Status.INCOMPLETE);
		} else {
			event = new ReservedEvent(name, task.getLocation(),task.getDescription(), task.getCategory(), reservedTimes, 
					GenericEvent.Status.UNDETERMINED);
		}
		/*
		if(reservedTimes.size() == 0){
			reserved = new ReservedEvent(name, task.getLocation(),
					task.getDescription(), task.getCategory(), prevReservedTimes, GenericEvent.Status.UNDETERMINED);
		} else{
		}*/

		return event;
	}

	/**
	 * Check the input task name for having quotations and extract the data out
	 * @param task
	 * @param input
	 * @return 
	 */
	private Event determineQuotedInput(Event task, String input){
		boolean isDoubleQuoted = false;
		boolean isSingleQuoted = false;

		int endIndex = 0;

		if(input.indexOf("\"") >= 0){
			int startQuoteIndex = input.indexOf("\"");
			endIndex = input.indexOf("\"", startQuoteIndex + 1);
			if(endIndex > 0){
				task.setName(input.substring(startQuoteIndex + 1, endIndex).trim());
				isDoubleQuoted = true;
			}
		} else if(input.indexOf("'") >= 0){
			int startQuoteIndex = input.indexOf("'");
			endIndex = input.indexOf("'",startQuoteIndex+ 1);
			if(endIndex > 0){
				task.setName(input.substring(startQuoteIndex + 1, endIndex));
				isSingleQuoted = true;
			}
		}

		int[] indexes = matchPatternOfFirstOccurrence(PATTERN_PREP_ALL, input);

		if(indexes[0] == 0 && indexes[1]!=0){			
			isNameDefined = false;
		} else if(indexes[0] == 0 && indexes[1] ==0){
			isNameDefined = true;
		} else{
			isNameDefined = true;
		}

		if(isSingleQuoted || isDoubleQuoted){
			if(endIndex != input.length()-1){
				int startIndex = endIndex + 1;
				endIndex = input.length();
				input = input.substring(startIndex, endIndex).trim();
			}
		}else if (isEdit && isNameDefined){
			task.setName(input.substring(0, indexes[0]).trim());
		}
		return task;
	}



	/**
	 * Extract information out from user input into name, start time, end time, location, note 
	 * based on the structure of the input
	 * @param task
	 * @param input
	 * @return Event object with updated fields
	 */
	private Event decodeDataFromInput(Event task, String input){
		String word = "";
		boolean isFound = false;
		boolean isPreposition = false;
		int startIndex = 0;
		int endIndex = startIndex;
		Pattern pattern;
		Matcher matcher;
		int[] matchPattern;

		input = input.trim();
		if(input.isEmpty()){
			task = null;
			return task;
		}

		pattern = Pattern.compile(PATTERN_KEYWORD_ALL, Pattern.CASE_INSENSITIVE);
		matcher = pattern.matcher(input);
		matchPattern = matchPatternOfFirstOccurrence(PATTERN_KEYWORD_ALL, input);

		if(matchPattern[0] == 0 && matchPattern[1] == 0){		/*No Keyword found*/
			input = extractLocationFromAt(task, input);
			
			pattern = Pattern.compile(PATTERN_PREP_ALL,Pattern.CASE_INSENSITIVE);
			matcher = pattern.matcher(input);
			matchPattern = matchPatternOfFirstOccurrence(PATTERN_PREP_ALL, input);		
			isPreposition = true;
		} 

		if(!task.getName().isEmpty()){
			isNameDefined = true;
		}else if(matchPattern[0] == 0 && matchPattern[1]!=0){			
			isNameDefined = false;
		} else if(matchPattern[0] == 0 && matchPattern[1] ==0){
			isNameDefined = true;
		} else{
			isNameDefined = true;
		}

		while(matcher.find()){
			endIndex = matcher.start();
			word = input.substring(matcher.start(), matcher.end()).trim();
			try {
				if(isPreposition){
					task = classifyDataFromPreposition(task, input, word, startIndex, endIndex);
				} else{
					task = classifyDataFromKeyword(task, input, word, startIndex, endIndex);
				}
			} catch (ParseException e) {

			}

			if(task != null){
				startIndex = matcher.end() + 1;
			} else{
				break;
			}
			isFound = true;
		}

		if(task == null){
			return task;
		}
		/*if preposition describing other fields is not found */
		if(!isFound && !isEdit){
			task.setName(input.substring(startIndex, input.length()));
			task.setStatus(Status.UNDETERMINED);
		} else if(!isFound && isEdit){
			task.setName(input.substring(startIndex, input.length()));
		} else {
			determineCategory(task);
		}

		return task;
	}

	private Event classifyDataFromKeyword(Event task, String input, String keyword, int startIndex, int endIndex){
		Date inputDate;
		String stringDate = null;
		String data = null;
		String time = null;
		String name = null;
		boolean isDay = false;
		int newStartIndex = 0;
		int newEndIndex = 0;
		SimpleDateFormat formatToString = new SimpleDateFormat("dd/MM/yyyy H:mm:ss");

		if(task.getName().isEmpty() && isNameDefined){
			name = input.substring(startIndex , endIndex).trim();
			task.setName(name);
		}
		
		if(task.getName().isEmpty() && !isEdit){
			task = null;
			return task;
		}
		
		if(keyword.equalsIgnoreCase(KEY_START_DATE) || keyword.equalsIgnoreCase(KEY_START_TIME)){
			
			newStartIndex = endIndex + KEY_START_DATE.length() + 1;
			String choppedInput = input.substring(newStartIndex, input.length()).trim();
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_KEYWORD_ALL, choppedInput)[0] + newStartIndex;
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex < newStartIndex){
				newEndIndex = input.length();
			} else if(newEndIndex > input.length()){
				newEndIndex = input.length();
			} else if(newStartIndex == newEndIndex){
				newEndIndex = input.length();
			}
			stringDate = input.substring(newStartIndex, newEndIndex).trim();
			inputDate = DateChecker.validateDate(stringDate);
			isDay = DateChecker.isDay;
			if(inputDate != null){
				task.setStartTime(inputDate);
			}
			/*extract time from the date if it is declared otherwise, dateTime[1] = null*/
			String[] dateTime = extractTimeFromDate(stringDate);
			recordedDate = dateTime[0];
			if(isDay){
				if(dateTime[0] == null && dateTime[1] != null && !stringDate.equals(dateTime[1])){
					task.setStartTime(DateChecker.writeTime(stringDate, DateChecker.convertAmPmToTime(dateTime[1])));
				} else if(dateTime[0] == null && dateTime[1] != null && stringDate.equals(dateTime[1])){
					time = DateChecker.convertAmPmToTime(dateTime[1]);
					Calendar cal = Calendar.getInstance();
					SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
					String today = sdf.format(new Date());
					Date todayDate = DateChecker.writeTime(today, time);
					task.setStartTime(todayDate);
					recordedDate = today;

					if(cal.getTime().after(todayDate)){
						int interval = 1;
						task.setStartTime(DateChecker.findDate(interval));

						String writtenDate = formatToString.format(task.getStartTime());
						task.setStartTime(DateChecker.writeTime(writtenDate, time));
						recordedDate = writtenDate;
					}
				} else if(dateTime[0] != null && dateTime[1] != null){	/*tues 11:00 or tues 11 pm*/
					task.setStartTime(DateChecker.writeTime(dateTime[0], DateChecker.convertAmPmToTime(dateTime[1])));
				}
			} else if(dateTime[0] != null && dateTime[1] != null){
				task.setStartTime(DateChecker.writeTime(dateTime[0], DateChecker.convertAmPmToTime(dateTime[1])));
			}
		} else if(keyword.equalsIgnoreCase(KEY_END_DATE) || keyword.equalsIgnoreCase(KEY_END_TIME)){

			newStartIndex = endIndex + KEY_END_DATE.length() + 1;
			String choppedInput = input.substring(newStartIndex, input.length()).trim();
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_KEYWORD_ALL, choppedInput)[0] + newStartIndex;
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex < newStartIndex){
				newEndIndex = input.length();
			} else if(newEndIndex > input.length()){
				newEndIndex = input.length();
			} else if(newStartIndex == newEndIndex){
				newEndIndex = input.length();
			}
			stringDate = input.substring(newStartIndex, newEndIndex).trim();
			inputDate = DateChecker.validateDate(stringDate);
			isDay = DateChecker.isDay;
			if(inputDate != null){
				task.setEndTime(inputDate);
			}

			String[] dateTime = extractTimeFromDate(stringDate);

			if(isDay){
				if(dateTime[0] == null && dateTime[1] != null && !stringDate.equals(dateTime[1])){
					time = DateChecker.convertAmPmToTime(dateTime[1]);
					task.setEndTime(DateChecker.writeTime(stringDate, time));
				} else if(dateTime[0] == null && dateTime[1] != null && stringDate.equals(dateTime[1])){
					time = DateChecker.convertAmPmToTime(dateTime[1]);
					Calendar cal = Calendar.getInstance();
					SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
					String today = sdf.format(new Date());
					Date todayDate = DateChecker.writeTime(today, time);
					task.setEndTime(todayDate);

					if(cal.getTime().after(todayDate)){
						int interval = 1;
						task.setEndTime(DateChecker.findDate(interval));

						String writtenDate = formatToString.format(task.getStartTime());
						task.setEndTime(DateChecker.writeTime(writtenDate, time));
					}
				} else if(dateTime[0] != null && dateTime[1] != null){
					time = DateChecker.convertAmPmToTime(dateTime[1]);
					task.setEndTime(DateChecker.writeTime(dateTime[0], time));
				} else if(dateTime[0] != null && dateTime[1] == null){
					task.setEndTime(DateChecker.writeTime(dateTime[0], TIME_BEFORE_MIDNIGHT));
				}
			} else if(dateTime[0] != null && dateTime[1] == null ){
				task.setEndTime(DateChecker.writeTime(dateTime[0], TIME_BEFORE_MIDNIGHT));
			} else if (dateTime[0] == null && dateTime[1] == null){
				task.setEndTime(DateChecker.writeTime(stringDate, TIME_BEFORE_MIDNIGHT));
			} else if(dateTime[0] == null && dateTime[1] != null && !stringDate.equals(dateTime[1])){
				task.setEndTime(DateChecker.writeTime(stringDate, DateChecker.convertAmPmToTime(dateTime[1])));
			} else if(dateTime[0] == null && dateTime[1] != null && stringDate.equals(dateTime[1])){
				task.setEndTime(DateChecker.writeTime(recordedDate, DateChecker.convertAmPmToTime(dateTime[1])));
			} else if(dateTime[0] != null && dateTime[1] != null){
				task.setEndTime(DateChecker.writeTime(dateTime[0], DateChecker.convertAmPmToTime(dateTime[1])));
			}

		} else if(keyword.equalsIgnoreCase(KEY_LOCATION)){
	
			newStartIndex = endIndex + KEY_LOCATION.length() + 1;
			String choppedInput = input.substring(newStartIndex, input.length()).trim();
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_KEYWORD_ALL, choppedInput)[0] + newStartIndex;
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex < newStartIndex){
				newEndIndex = input.length();
			} else if(newEndIndex > input.length()){
				newEndIndex = input.length();
			} else if(newStartIndex == newEndIndex){
				newEndIndex = input.length();
			}

			data = input.substring(newStartIndex, newEndIndex).trim();
			task.setLocation(data);
		} else if(keyword.equalsIgnoreCase(KEY_NOTE)){
	
			newStartIndex = endIndex + KEY_NOTE.length() + 1;
			String choppedInput = input.substring(newStartIndex, input.length()).trim();
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_KEYWORD_ALL, choppedInput)[0] + newStartIndex;
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex < newStartIndex){
				newEndIndex = input.length();
			} else if(newEndIndex > input.length()){
				newEndIndex = input.length();
			} else if(newStartIndex == newEndIndex){
				newEndIndex = input.length();
			}

			data = input.substring(newStartIndex, newEndIndex).trim();
			task.setDescription(data);
		}

		return task;
	}

	private Event classifyDataFromPreposition(Event task, String input, String preposition,
			int startIndex, int endIndex) throws ParseException{
		Date inputDate;
		String stringDate = null;
		String time = null;
		String name = null;
		boolean isDay = false;
		int newStartIndex = 0;
		int newEndIndex = 0;
		SimpleDateFormat formatToString = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");

		if(task.getName().isEmpty() && isNameDefined){
			name = input.substring(startIndex , endIndex).trim();
			task.setName(name);
		}
		
		if(task.getName().isEmpty() && !isEdit){
			task = null;
			return task;
		}

		if(preposition.equalsIgnoreCase(PREP_ON)){

			newStartIndex = endIndex + PREP_ON.length() + 1;
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_AT_OR_BY_OR_NEXT, input)[0];
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex > newStartIndex){
				isAfterOn = true;
			}
			extractDateFromOnPreposition(task, input, newStartIndex, newEndIndex, formatToString); 

		} else if(preposition.equalsIgnoreCase(PREP_AT)){

			/*check for anymore preposition 'at' which describe location*/
			newStartIndex = endIndex + PREP_AT.length() + 1;
			newEndIndex = matchPatternOfLastOccurrence(PATTERN_AT, input)[0];
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex < newStartIndex){
				newEndIndex = input.length();
			}
			extractDateFromAtPreposition(task, input, newStartIndex, newEndIndex, formatToString);

		} else if(preposition.equalsIgnoreCase(PREP_BY)){

			newStartIndex = endIndex + PREP_BY.length() + 1;
			newEndIndex =  matchPatternOfLastOccurrence(PATTERN_AT, input)[0];
			/* no more preposition, the end of the line*/
			if(newEndIndex == 0){
				newEndIndex = input.length();
			}

			extractDateFromByPreposition(task, input, newStartIndex, newEndIndex, formatToString);

		} else if(preposition.equalsIgnoreCase(PREP_FROM)){

			newStartIndex = endIndex + PREP_FROM.length() + 1;
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_TO, input)[0];

			if(newEndIndex == 0){
				return null;
			}

			extractDateFromFromPreposition(task, input, newStartIndex, newEndIndex, formatToString);

			newStartIndex = matchPatternOfFirstOccurrence(PATTERN_TO, input)[1] + 1;
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_AT, input)[0];

			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex < newStartIndex){
				newEndIndex = input.length();
			}
			
			extractDateFromToPreposition(task, input, newStartIndex, newEndIndex);

		} else if(preposition.equalsIgnoreCase(PREP_NEXT)){
			
			newStartIndex = endIndex + PREP_NEXT.length() + 1;
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_AT_OR_BY, input)[0];
			
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex > newStartIndex){
				isAfterNext = true;
			}
			task = extractDateFromNextPreposition(task, input, newStartIndex, newEndIndex, formatToString);
		} else if(preposition.equalsIgnoreCase(PREP_TMR)){
			newStartIndex = endIndex + PREP_TMR.length() + 1;
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_AT_OR_BY, input)[0];
			
			if(newStartIndex > input.length()){
				newStartIndex = input.length();
			}
			
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex <= newStartIndex){
				newEndIndex = input.length();
			}
			extractDateFromTomorrowPreposition(task, input, newStartIndex, newEndIndex, formatToString);
			
		} else if(preposition.equalsIgnoreCase(PREP_TOMORROW)){
			newStartIndex = endIndex + PREP_TOMORROW.length() + 1;
			newEndIndex = matchPatternOfFirstOccurrence(PATTERN_AT_OR_BY, input)[0];

			if(newStartIndex > input.length()){
				newStartIndex = input.length();
			}
			if(newEndIndex == 0){
				newEndIndex = input.length();
			} else if(newEndIndex <= newStartIndex){
				newEndIndex = input.length();
			} else{
				
			}
			extractDateFromTomorrowPreposition(task, input, newStartIndex, newEndIndex, formatToString);
		}

		return task;
	}
	
	private Event extractDateFromTomorrowPreposition(Event task, String input, int newStartIndex, int newEndIndex,
			SimpleDateFormat formatToString){
		Date inputDate;
		String stringDate;
		String time = null;
		boolean isDay;
		int interval = 1;
		
		stringDate = input.substring(newStartIndex, newEndIndex).trim();
		if(stringDate.isEmpty()){
			task.setStartTime(DateChecker.findDate(interval));
			task.setEndTime(DateChecker.findDate(interval));
			String writtenDate = formatToString.format(task.getEndTime());
			task.setEndTime(DateChecker.writeTime(writtenDate, TIME_BEFORE_MIDNIGHT_SEC));
			task.setCategory(GenericEvent.Category.EVENT);
			return task;
		}
		
		String[] dateTime = extractTimeFromDate(stringDate);
		inputDate = DateChecker.validateDate(stringDate);

		if(dateTime[0] == null && dateTime[1] != null && stringDate.equals(dateTime[1])) {
			task.setCategory(GenericEvent.Category.DEADLINE);
			time = DateChecker.convertAmPmToTime(dateTime[1]);
			task.setEndTime(DateChecker.findDate(interval));

			String writtenDate = formatToString.format(task.getEndTime());
			task.setEndTime(DateChecker.writeTime(writtenDate, time));
		} 
		
		return task;
	}

	private Event extractDateFromNextPreposition(Event task, String input, int newStartIndex, int newEndIndex,
			SimpleDateFormat formatToString){
		Date inputDate;
		String stringDate;
		boolean isDay;
		
		stringDate = input.substring(newStartIndex, newEndIndex).trim();

		String[] dateTime = extractTimeFromDate(stringDate);
		inputDate = DateChecker.validateDate(stringDate);
		isDay = DateChecker.isDay;
		
		if(isDay){
			if(dateTime[0] == null && dateTime[1] != null){
				return null;
			} else if(dateTime[0] != null && dateTime[1] != null){		/*next Friday 11:00*/
				Date nextWeekDate = DateChecker.convertNextWeekDayToDate(stringDate);
				task.setStartTime(Constant.MIN_DATE);
				
				String writtenDate = formatToString.format(nextWeekDate);
				task.setEndTime(DateChecker.writeTime(writtenDate, DateChecker.convertAmPmToTime(dateTime[1])));
				task.setCategory(Category.DEADLINE);
			} else if(dateTime[0] == null && dateTime[1] == null){   /*next Friday*/
				Date nextWeekDate = DateChecker.convertNextWeekDayToDate(stringDate);
				task.setStartTime(nextWeekDate);
				
				String writtenDate = formatToString.format(nextWeekDate);
				task.setEndTime(DateChecker.writeTime(writtenDate, TIME_BEFORE_MIDNIGHT_SEC));
				task.setCategory(GenericEvent.Category.EVENT);
			}
		} else{ 
			return null;
		}
		return task;
	}

	private void extractDateFromAtPreposition(Event task, String input, int newStartIndex, int newEndIndex,
			SimpleDateFormat formatToString) {
		Date inputDate;
		String stringDate;
		String time = null;
		stringDate = input.substring(newStartIndex, newEndIndex).trim();

		String[] dateTime = extractTimeFromDate(stringDate);
		if(isAfterOn || isAfterNext){
			String writtenDate = formatToString.format(task.getEndTime());	
			time = DateChecker.convertAmPmToTime(dateTime[1]);
			task.setStartTime(Constant.MIN_DATE);
			task.setEndTime(DateChecker.writeTime(writtenDate, time));
		} else{
			if(dateTime[0] == null && dateTime[1] != null && !stringDate.equals(dateTime[1])){		
				time = DateChecker.convertAmPmToTime(dateTime[1]);
				task.setEndTime(DateChecker.writeTime(stringDate, time));
				task.setCategory(GenericEvent.Category.DEADLINE);
			} else if(dateTime[0] == null && dateTime[1] != null && stringDate.equals(dateTime[1])) {/*stringDate = 12:00 and dateTime[1] = 12:00*/
				task.setCategory(GenericEvent.Category.DEADLINE);
				time = DateChecker.convertAmPmToTime(dateTime[1]);
				Calendar cal = Calendar.getInstance();
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
				String today = sdf.format(new Date());
				Date todayDate = DateChecker.writeTime(today, time);
				task.setEndTime(todayDate);

				if(cal.getTime().after(todayDate)){
					int interval = 1;
					task.setEndTime(DateChecker.findDate(interval));

					String writtenDate = formatToString.format(task.getEndTime());
					task.setEndTime(DateChecker.writeTime(writtenDate, time));
				}
			} else if(dateTime[0] != null && dateTime[1] != null){
				time = DateChecker.convertAmPmToTime(dateTime[1]);
				if(time!= null){
					task.setEndTime(DateChecker.writeTime(dateTime[0], time));
					task.setCategory(GenericEvent.Category.DEADLINE);
				}
			} 

		}
	
		if(time == null){
			inputDate = DateChecker.validateDate(stringDate);

			if(inputDate != null){
				task.setStartTime(inputDate);
				task.setEndTime(DateChecker.writeTime(stringDate, TIME_BEFORE_MIDNIGHT));
				task.setCategory(GenericEvent.Category.DEADLINE);
			}
		}
	}



	private void extractDateFromToPreposition(Event task, String input, int newStartIndex, int newEndIndex) {
		Date inputDate;
		String stringDate;
		boolean isDay;
		String[] dateTime;
	
		stringDate = input.substring(newStartIndex, newEndIndex).trim();		
		inputDate = DateChecker.validateDate(stringDate);
		isDay = DateChecker.isDay;

		dateTime = extractTimeFromDate(stringDate);

		if(isDay){
			if(dateTime[0] == null && dateTime[1] != null && stringDate.equals(dateTime[1])){    		/*to 3 am or to 13:00*/
				task.setEndTime(DateChecker.writeTime(recordedDate, DateChecker.convertAmPmToTime(dateTime[1])));
			} else if(dateTime[0] == null && dateTime[1] != null && !stringDate.equals(dateTime[1])){	/*to friday 3 am or to friday 13:00*/
				task.setEndTime(DateChecker.writeTime(stringDate, dateTime[1]));
			} else if(dateTime[0] != null && dateTime[1] != null){		/* to friday 12:00 */
				task.setEndTime(DateChecker.writeTime(dateTime[0], DateChecker.convertAmPmToTime(dateTime[1])));
			} else if(dateTime[0] != null && dateTime[1] == null){
				task.setEndTime(DateChecker.writeTime(dateTime[0], TIME_BEFORE_MIDNIGHT_SEC));
			} else if(dateTime[0] == null && dateTime[1] == null){
				task.setEndTime(DateChecker.writeTime(stringDate, TIME_BEFORE_MIDNIGHT_SEC));
			}
		} else if (dateTime[1] == null){
			task.setEndTime(DateChecker.writeTime(stringDate, TIME_BEFORE_MIDNIGHT_SEC));

		} else if(dateTime[0] == null && dateTime[1] != null && !stringDate.equals(dateTime[1])){

			if(dateTime[1].contains(TIME_BEFORE_MIDNIGHT) || dateTime[1].contains("11:59 pm")){
				task.setEndTime(DateChecker.writeTime(stringDate, TIME_BEFORE_MIDNIGHT_SEC));
			} else{
				task.setEndTime(DateChecker.writeTime(stringDate, DateChecker.convertAmPmToTime(dateTime[1])));
			}
		} else if(dateTime[0] == null && dateTime[1] != null && stringDate.equals(dateTime[1])){

			if(dateTime[1].contains(TIME_BEFORE_MIDNIGHT) || dateTime[1].contains("11:59 pm")){
				task.setEndTime(DateChecker.writeTime(recordedDate, TIME_BEFORE_MIDNIGHT_SEC));
			} else{
				task.setEndTime(DateChecker.writeTime(recordedDate, DateChecker.convertAmPmToTime(dateTime[1])));
			}
		} else if(dateTime[0] != null && dateTime[1] != null){
			if(dateTime[1].contains(TIME_BEFORE_MIDNIGHT) || dateTime[1].contains("11:59 pm")){
				task.setEndTime(DateChecker.writeTime(dateTime[0], TIME_BEFORE_MIDNIGHT_SEC));
			} else{
				task.setEndTime(DateChecker.writeTime(dateTime[0], DateChecker.convertAmPmToTime(dateTime[1])));
			}
		}
	}



	private void extractDateFromFromPreposition(Event task, String input, int newStartIndex, int newEndIndex,
			SimpleDateFormat formatToString) {
		Date inputDate;
		String stringDate;
		String time;
		boolean isDay;
		stringDate = input.substring(newStartIndex, newEndIndex).trim();
		inputDate = DateChecker.validateDate(stringDate);
		isDay = DateChecker.isDay;

		if(inputDate != null){
			task.setStartTime(inputDate);
		}
		String[] dateTime = extractTimeFromDate(stringDate);
		recordedDate = dateTime[0];

		if(isDay){

			if(dateTime[0] == null && dateTime[1] != null && stringDate.equals(dateTime[1])){
				time = DateChecker.convertAmPmToTime(dateTime[1]);
				Calendar cal = Calendar.getInstance();
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
				String today = sdf.format(new Date());
				Date todayDate = DateChecker.writeTime(today, time);
				task.setStartTime(todayDate);
				recordedDate = today;

				if(cal.getTime().after(todayDate)){
					int interval = 1;
					task.setStartTime(DateChecker.findDate(interval));

					String writtenDate = formatToString.format(task.getStartTime());
					task.setStartTime(DateChecker.writeTime(writtenDate, time));
					recordedDate = writtenDate;
				} 
				task.setCategory(GenericEvent.Category.EVENT);
			} else if(dateTime[0] == null && dateTime[1] != null && !stringDate.equals(dateTime[1])){
				task.setStartTime(DateChecker.writeTime(stringDate, DateChecker.convertAmPmToTime(dateTime[1])));
				task.setCategory(GenericEvent.Category.EVENT);
			} else if(dateTime[0] != null && dateTime[1] != null){			/*from friday 1:00*/
				task.setStartTime(DateChecker.writeTime(dateTime[0], DateChecker.convertAmPmToTime(dateTime[1])));
				task.setCategory(GenericEvent.Category.EVENT);
			}
		} else if(dateTime[0] != null && dateTime[1] != null ){
			task.setStartTime(DateChecker.writeTime(dateTime[0], DateChecker.convertAmPmToTime(dateTime[1])));
			task.setCategory(GenericEvent.Category.EVENT);
		}
	}



	private void extractDateFromByPreposition(Event task, String input, int newStartIndex, int newEndIndex,
			SimpleDateFormat formatToString) {
		Date inputDate;
		String stringDate;
		String time;
		
		stringDate = input.substring(newStartIndex, newEndIndex).trim();
		inputDate = DateChecker.validateDate(stringDate);
	
		if(inputDate != null){
			task.setEndTime(DateChecker.writeTime(stringDate, TIME_BEFORE_MIDNIGHT));
		}
		
		String[] dateTime = extractTimeFromDate(stringDate);

		if(isAfterOn || isAfterNext){
			String writtenDate = formatToString.format(task.getEndTime());	
			task.setStartTime(Constant.MIN_DATE);
			task.setEndTime(DateChecker.writeTime(writtenDate, DateChecker.convertAmPmToTime(dateTime[1])));
		} else{
			/*check date time in Day of the week format*/
			/*e.g. by Sun 11 am or on Sun by 11 am*/
			task.setStartTime(Constant.MIN_DATE);

			if(dateTime[0] == null && dateTime[1] != null){
				time = DateChecker.convertAmPmToTime(dateTime[1]);
				Calendar cal = Calendar.getInstance();
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
				String today = sdf.format(new Date());
				Date todayDate = DateChecker.writeTime(today, time);

				if(stringDate.equals(dateTime[1])){
					task.setEndTime(DateChecker.writeTime(today, time));
				} else{
					task.setEndTime(DateChecker.writeTime(stringDate, time));
				}

				if(cal.getTime().after(task.getEndTime())){
					int interval = 7;
					task.setEndTime(DateChecker.findDate(interval));

					String writtenDate = formatToString.format(task.getEndTime());
					task.setEndTime(DateChecker.writeTime(writtenDate, time));
				}

			} else if(dateTime[0] != null && dateTime[1] != null){
				time = DateChecker.convertAmPmToTime(dateTime[1]);
				Calendar cal = Calendar.getInstance();
				SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
				String today = sdf.format(new Date());
				Date todayDate = DateChecker.writeTime(today, time);

				task.setEndTime(DateChecker.writeTime(dateTime[0], time));				
				if(cal.getTime().after(task.getEndTime())){
					int intDaySet = task.getEndTime().getDay();
					Calendar calendar = Calendar.getInstance();
					Date dateToday = new Date();
					calendar.setTime(dateToday);
					int intToday = calendar.get(Calendar.DAY_OF_WEEK);
					task.setEndTime(DateChecker.findDate(DAYS_IN_WEEK));

					String writtenDate = formatToString.format(task.getEndTime());
					task.setEndTime(DateChecker.writeTime(writtenDate, time));
				}
			}
		}
		task.setCategory(GenericEvent.Category.DEADLINE);

	}

	private void extractDateFromOnPreposition(Event task, String input, int newStartIndex, int newEndIndex,
			SimpleDateFormat formatToString) {
		Date inputDate;
		String stringDate;
		String time;
		boolean isDay;
	

		stringDate = input.substring(newStartIndex, newEndIndex).trim(); 
		inputDate = DateChecker.validateDate(stringDate);
		isDay = DateChecker.isDay;
		if(inputDate != null){/*set starttime and endtime for the whole day event, e.g. on Sun*/
			task.setStartTime(inputDate);
			task.setEndTime(DateChecker.writeTime(stringDate, TIME_BEFORE_MIDNIGHT_SEC));
			task.setCategory(GenericEvent.Category.EVENT);
		}

	
		/*extract time from the date if it is declared otherwise, dateTime[1] = null*/
		String[] dateTime = extractTimeFromDate(stringDate);

		if(dateTime[0] == null && dateTime[1] != null){
			task.setStartTime(Constant.MIN_DATE);
			time = DateChecker.convertAmPmToTime(dateTime[1]);
			Calendar cal = Calendar.getInstance();
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
			String today = sdf.format(new Date());
			Date todayDate = DateChecker.writeTime(today, time);
			
			if(time != null){
				task.setEndTime(DateChecker.writeTime(stringDate, time));
				task.setCategory(GenericEvent.Category.DEADLINE);
			}
			if(time != null && cal.getTime().after(task.getEndTime())){
				int intDaySet = task.getEndTime().getDay();
				Calendar calendar = Calendar.getInstance();
				Date dateToday = new Date();
				calendar.setTime(dateToday);
				int intToday = calendar.get(Calendar.DAY_OF_WEEK);
				task.setEndTime(DateChecker.findDate(DAYS_IN_WEEK));

				String writtenDate = formatToString.format(task.getEndTime());
				task.setEndTime(DateChecker.writeTime(writtenDate, time));
			}
			
		} else if(dateTime[0] != null && dateTime[1] != null){ /*e.g. on 31/6/16 9 am or 31/6/16 21:00*/
			task.setStartTime(Constant.MIN_DATE);
			time = DateChecker.convertAmPmToTime(dateTime[1]);
			if(time != null){
				task.setEndTime(DateChecker.writeTime(dateTime[0], time));
				task.setCategory(GenericEvent.Category.DEADLINE);
			}
		}
	}

	/**
	 * extract time from date, the method looks for pattern such as 11 am, 11 pm, 23:00 
	 * @param date - input date
	 * @return dateTme[] with dateTime[0] contains date, dateTime[1] contains time
	 */
	private String[] extractTimeFromDate(String date){
		int startIndex = 0;
		int endIndex = 0;
		String[] dateTime = {null, null};

		int[] matchedAtData = matchPatternOfFirstOccurrence(PATTERN_AT, date);
		/*if 'at' is found in date*/
		if(matchedAtData[0] > 0){
			date = date.substring(matchedAtData[1], date.length()).trim();
			dateTime[0] = date;
			return dateTime;
		}
		date.trim();
		int[] matchedData = matchPatternOfFirstOccurrence(PATTERN_AM_OR_PM, date);
		int[] matchedSpace = matchPatternOfFirstOccurrence(PATTERN_SPACE, date);
		/*if 'am' or 'pm' keyword comes before the date e.g. 3 pm Friday*/
		if(matchedData[1] != date.length() && matchedData[0] > 0){
			dateTime[0] = date.substring(matchedData[1], date.length()).trim();
			dateTime[1] = date.substring(0, matchedData[1]).trim();
		} else {
			dateTime[1] = date;
		}

		if(matchedSpace[1] == matchedData[0] && matchedSpace[1] !=0 && matchedData[0] !=0){
			return dateTime;
		}else if(matchedData[0] > 0){			/*put date in dateTime[0] and time in dateTime[1]*/
			dateTime[0] = date.substring(0, matchedSpace[0]).trim();
			dateTime[1] = date.substring(matchedSpace[0], date.length()).trim();
			return dateTime;
		} 

		int[] matchedColumn = matchPatternOfFirstOccurrence(PATTERN_COLUMN, date);
		int[] matchedLastSpace = matchPatternOfLastOccurrence(PATTERN_SPACE, date);

		if(matchedColumn[1] < matchedLastSpace[1]){
			startIndex =  0;
			endIndex = matchedLastSpace[0];
			dateTime[0] = date.substring(matchedLastSpace[1], date.length());

		} else if(matchedColumn[1] > matchedLastSpace[1]){
			endIndex = date.length();
			dateTime[0] = date.substring(0,matchedLastSpace[0]).trim();
			if(dateTime[0]!= null && dateTime[0].isEmpty()){
				dateTime[0] = null;
			}else if(dateTime[0]!= null && !dateTime[0].isEmpty() && DateChecker.convertDayToDate(dateTime[0]) != null){/**friday 2:00 to 3:00**/
				startIndex = matchedLastSpace[0];
			}else if(dateTime[0]!= null && !dateTime[0].isEmpty() && DateChecker.validateDate(dateTime[0]) != null){
				startIndex = matchedLastSpace[0];
			}else{
				dateTime[0] = null;
			}
		}

		if(matchedColumn[0] > 0){
			dateTime[1] = date.substring(startIndex, endIndex).trim();

		} else{
			dateTime[1] = null;
		}

		return dateTime;
	}

	private String extractLocationFromAt(Event event, String input){
		String unknownData = "";
		int[] indexes = matchPatternOfLastOccurrence(PATTERN_AT, input);

		if(indexes[0] != 0 && indexes[1] != 0 && indexes[0] != indexes[1]){
			unknownData = input.substring(indexes[1], input.length()).trim();
			if(DateChecker.validateDate(unknownData) ==null && DateChecker.validateTime(unknownData) == null){
				event.setLocation(unknownData);
				return (input.substring(0, indexes[0]).trim());
			}
		} 
		return input;
	}

	/**
	 * This method extracts the description out of the input and set the value to the Event object
	 * @param event
	 * @param input
	 * @return the remaining String input which are left to be processed 
	 */
	private String extractDescription(Event event, String input){
		int startIndex = input.indexOf("//");
		int offset = 2;

		//no description or note input
		if (startIndex < 0){
			return input;
		}

		int endIndex = input.length();
		String description = input.substring(startIndex + offset, endIndex).trim();
		event.setDescription(description);

		return (input.substring(0,startIndex).trim());
	}

	/**
	 * This method finds the pattern provided which is used in data extraction
	 * @param desiredPattern-RegEx Pattern for matching the specific preposition
	 * @param input- user's input without the description or note
	 * @return an integer array which contains indexes of the first occurrence of the desired word
	 * 			[0] - start index  , [1] - end index
	 */
	private int[] matchPatternOfFirstOccurrence(String desiredPattern, String input){
		int startIndex = 0;
		int endIndex = 0;

		Pattern pattern = Pattern.compile(desiredPattern,Pattern.CASE_INSENSITIVE);
		Matcher matcher = pattern.matcher(input);

		if(matcher.find()){
			startIndex = matcher.start();
			endIndex = matcher.end();
		}

		int[] resultedIndex = new int[]{startIndex, endIndex};

		return resultedIndex;
	}

	/**
	 * This method finds the pattern provided which is used in data extraction
	 * @param desiredPattern-RegEx Pattern for matching the specific preposition
	 * @param input- user's input without the description or note
	 * @return an integer array which contains indexes of the last occurrence of the desired word
	 * 			[0] - start index  , [1] - end index
	 */
	private static int[] matchPatternOfLastOccurrence(String desiredPattern, String input){
		int startIndex = 0;
		int endIndex = 0;

		Pattern pattern = Pattern.compile(desiredPattern,Pattern.CASE_INSENSITIVE);
		Matcher matcher = pattern.matcher(input);

		while(matcher.find()){
			startIndex = matcher.start();
			endIndex = matcher.end();
		}

		int[] resultedIndex = new int[]{startIndex, endIndex};

		return resultedIndex;
	}

	/**
	 * To be used with Confirm Command
	 * @param event
	 * @return Event object with updated Category field 
	 */
	private Event determineCategory(Event event){
		if(event.getStartTime() == Constant.MIN_DATE && event.getEndTime() == Constant.MAX_DATE){
			event.setCategory(GenericEvent.Category.FLOATING);
		} else if(event.getStartTime() == Constant.MIN_DATE && event.getEndTime() != Constant.MAX_DATE){
			event.setCategory(GenericEvent.Category.DEADLINE);
		} else if(event.getStartTime() != Constant.MIN_DATE && event.getEndTime() != Constant.MAX_DATE){
			event.setCategory(GenericEvent.Category.EVENT);
		}

		return event;
	}

	/**
	 * To be used with Select and Delete Command, when the user chooses by Category
	 * @param userInput
	 * @return Category
	 */
	private GenericEvent.Category classifyCategory(String userInput){

		if(userInput.equalsIgnoreCase(Constant.CATEGORY_DEADLINE)){
			return GenericEvent.Category.DEADLINE;
		} else if(userInput.equalsIgnoreCase(Constant.CATEGORY_EVENT)){
			return GenericEvent.Category.EVENT;
		} else if(userInput.equalsIgnoreCase(Constant.CATEGORY_FLOATING)){
			return GenericEvent.Category.FLOATING;
		}

		return GenericEvent.Category.NULL;
	}

	/**
	 * To be used with Select and Delete Command, when the user chooses by Status
	 * @param userInput
	 * @return Status
	 */
	private GenericEvent.Status classifyStatus(String userInput){

		if(userInput.equalsIgnoreCase(Constant.STATUS_INCOMPLETE)){
			return GenericEvent.Status.INCOMPLETE;
		}else if(userInput.equalsIgnoreCase(Constant.STATUS_COMPLETE)){
			return GenericEvent.Status.COMPLETE;
		}else if(userInput.equalsIgnoreCase(Constant.STATUS_UNDETERMINED)){
			return GenericEvent.Status.UNDETERMINED;
		}
		return GenericEvent.Status.NULL;

	}


	private CommandType getCommandType(String command){
		command = command.toLowerCase();
		if (command.equalsIgnoreCase("add")){
			return CommandType.ADD;
		}else if (command.equalsIgnoreCase("delete")){
			return CommandType.DELETE;
		}else if (command.equalsIgnoreCase("edit") || 
				command.equalsIgnoreCase("e")){
			return CommandType.EDIT;
		}else if (command.contains("export")){
			return CommandType.EXPORT;
		}else if (command.contains("import")){
			return CommandType.IMPORT;
		}else if (command.equalsIgnoreCase("block") || command.equalsIgnoreCase("reserve")){
			return CommandType.RESERVE;
		}else if (command.equalsIgnoreCase("confirm")){
			return CommandType.CONFIRM;
		}else if (command.equalsIgnoreCase("undo")){
			return CommandType.UNDO;
		}else if (command.equalsIgnoreCase("select")){
			return CommandType.SELECT;
		}else if (command.equalsIgnoreCase("changetab")){
			return CommandType.CHANGETAB;
		}else if (command.equalsIgnoreCase("complete")){
			return CommandType.COMPLETE;
		}

		return CommandType.INVALID;
	}

	private String getFirstWord(String input){
		return input.trim().split("\\s+")[0];
	}

	private String removeFirstWord(String input){
		return input.replaceFirst("\\b"+getFirstWord(input)+"\\b", "").trim();
	}

}
```
###### /src/parser/TestParser.java
``` java
 *
 */
public class TestParser {

	public void qaTesting() throws ParseException{
		/**Boundary value analysis**/
		testAddValidDate();
		
		testAddInvalidDate();
		
		testAddDeadline();
		
		testAddEvent();
	}

	public void testDirectory(){
		Parser parse = new Parser();
		GenericEvent task = new Event();
		Event expected = new Event();
		task = parse.testingDeterminedStuff("import C:/whatever/data");
		expected.setName("C:/whatever/data");
		
		assertEquals(expected.getName(), task.getName());
	}
	public void testReservedEvent() throws ParseException{
		Date startDate1, endDate1, startDate2, endDate2;
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");

		Parser parse = new Parser();
		GenericEvent reserved = new ReservedEvent();
		ReservedEvent expected = new ReservedEvent();
		ArrayList<TimePair> times = new ArrayList<>();
		TimePair time1 = new TimePair(format.parse("1/4/2016 00:00:00"),
				format.parse("1/4/2016 23:59:01"));
		TimePair time2 = new TimePair(format.parse("3/4/2016 00:00:00"),
				format.parse("3/4/2016 23:59:01"));
		times.add(time1);
		times.add(time2);

		/*
		reserved = parse.testingReservedStuff("reserve meeting from sat 3 pm to sat 5 pm and from sun 2:00 to sun 3:00");
		assertEquals("meeting", reserved.getName());
		startDate1 = reserved.getReservedTimes().get(0).getStartTime();
		endDate1 = reserved.getReservedTimes().get(0).getEndTime();
		startDate2 = reserved.getReservedTimes().get(1).getStartTime();
		endDate2 = reserved.getReservedTimes().get(1).getEndTime();
		
		reserved = parse.testingReservedStuff("reserve meeting by 2/4/16 and by 3/4/16 at IVLE // description");
				
		expected.setReservedTimes(times);
		
		assertEquals("meeting", reserved.getName());
		assertEquals("description", reserved.getDescription());
		assertEquals("IVLE", reserved.getLocation());
		startDate1 = reserved.getReservedTimes().get(0).getStartTime();
		endDate1 = reserved.getReservedTimes().get(0).getEndTime();
		startDate2 = reserved.getReservedTimes().get(1).getStartTime();
		endDate2 = reserved.getReservedTimes().get(1).getEndTime();
		
		reserved = parse.testingReservedStuff("block meeting by fri and by sun at Library // description");
		
		assertEquals("meeting", reserved.getName());
		assertEquals("description", reserved.getDescription());
		assertEquals("Library", reserved.getLocation());
		startDate1 = reserved.getReservedTimes().get(0).getStartTime();
		endDate1 = reserved.getReservedTimes().get(0).getEndTime();
		startDate2 = reserved.getReservedTimes().get(1).getStartTime();
		endDate2 = reserved.getReservedTimes().get(1).getEndTime();
		
	
		reserved = parse.testingReservedStuff("reserve meeting from 1/4/16 3:00 to 2/4/16 5:00"
				+ " and from 1/4/16 3 pm to 1/4/16 5 pm");
		assertEquals("meeting", reserved.getName());
		startDate1 = reserved.getReservedTimes().get(0).getStartTime();
		endDate1 = reserved.getReservedTimes().get(0).getEndTime();
		startDate2 = reserved.getReservedTimes().get(1).getStartTime();
		endDate2 = reserved.getReservedTimes().get(1).getEndTime();*/
		
		reserved = parse.testingReservedStuff("reserve meeting from 2/4/16 3 pm to 2/4/16 5 pm"
				+ " and from 3/4/16 3 pm to 3/4/16 5 pm and 5/4/16"); 
		String name = reserved.getName();
		
		assertEquals("meeting 5/4/16", reserved.getName());
		startDate1 = ((ReservedEvent) reserved).getReservedTimes().get(0).getStartTime();
		endDate1 = ((ReservedEvent) reserved).getReservedTimes().get(0).getEndTime();
		startDate2 = ((ReservedEvent) reserved).getReservedTimes().get(1).getStartTime();
		endDate2 = ((ReservedEvent) reserved).getReservedTimes().get(1).getEndTime();
		
		reserved = parse.testingReservedStuff("reserve meeting"); 
		name = reserved.getName();
		
		assertEquals("meeting", reserved.getName());
		startDate1 = ((ReservedEvent) reserved).getReservedTimes().get(0).getStartTime();
		endDate1 = ((ReservedEvent) reserved).getReservedTimes().get(0).getEndTime();

	}
	public void testAddValidDate() throws ParseException{
		Parser parse = new Parser();
		GenericEvent task;
		Event expected = new Event();
		task = parse.testingDeterminedStuff("add borderline date on 1/1/1970");
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");

		if(task.getStatus() == Status.UNDETERMINED){
			
		} else{
			expected.setStartTime(format.parse("1/1/1970 00:00:00"));
			expected.setEndTime(format.parse("1/1/1970 23:59:01"));
			assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
			assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
			
			task = parse.testingDeterminedStuff("add borderline date on 23/3/2036");
			expected.setStartTime(format.parse("23/3/2036 00:00:00"));
			expected.setEndTime(format.parse("23/3/2036 23:59:01"));
			assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
			assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
			
			task = parse.testingDeterminedStuff("add borderline date on 23/3/9999");
			expected.setStartTime(format.parse("23/3/9999 00:00:00"));
			expected.setEndTime(format.parse("23/3/1999 23:59:01"));
			assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
			assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		}

	}
	
	/**	Checking invalid date 
	 * @return initialized value**/
	public void testAddInvalidDate() throws ParseException{
		Parser parse = new Parser();
		GenericEvent task;
		Event expected = new Event();
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");

		task = parse.testingDeterminedStuff("add invalid date on 00/00/0000");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(Constant.MAX_DATE);
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		
		task = parse.testingDeterminedStuff("add invalid date on 1/13/2015");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(Constant.MAX_DATE);
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		
		task = parse.testingDeterminedStuff("add invalid date on 99/99/9999");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(Constant.MAX_DATE);
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
	}
	
	public void testFloating() throws ParseException{
		Parser parse = new Parser();
		GenericEvent task;
		Event expected = new Event();
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		
		task = parse.testingDeterminedStuff("add shit");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(Constant.MAX_DATE);
		expected.setStatus(Status.UNDETERMINED);
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		assertEquals(expected.getStatus(), ((Event) task).getStatus());	

	}
	
	/**equivalence partitioning**/
	public void testAddDeadline() throws ParseException{
		Parser parse = new Parser();
		GenericEvent task;
		Event expected = new Event();
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");

		task = parse.testingDeterminedStuff("add deadline by thurs 22:00");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("7/4/2016 22:00:00"));
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		
		task = parse.testingDeterminedStuff("add deadline by 27/4/16 23:00");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("27/4/2016 23:00:00"));
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		
		task = parse.testingDeterminedStuff("add deadline at 9 am");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("5/4/2016 9:00:00"));
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		
		/*
		task = parse.testingDeterminedStuff("add deadline by 27 apr 16");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("27/4/2016 23:59:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		task = parse.testingDeterminedStuff("add deadline by sunday");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("3/4/2016 23:59:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		task = parse.testingDeterminedStuff("add deadline on Sunday 6 pm");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("3/4/2016 18:00:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		
	
		
		
		task = parse.testingDeterminedStuff("add deadline on Sunday at 5 pm");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("3/4/2016 17:00:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());*/
		
	}
	
	@Test
	public void testNewAddEvent() throws ParseException{
		Parser parse = new Parser();
		GenericEvent task;
		Event expected = new Event();
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		Date startDate, endDate;
		
		task = parse.testingDeterminedStuff("add event location ivle note what starttime 8/4/16 11:30 pm endtime 8/4/16 11:45 pm ");
		expected.setStartTime(format.parse("8/4/2016 23:30:00"));
		expected.setEndTime(format.parse("8/4/2016 23:45:00"));
		expected.setLocation("ivle");
		expected.setDescription("what");
		expected.setCategory(Category.EVENT);
		expected.setStatus(Status.INCOMPLETE);
		
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();

		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());
		assertEquals(expected.getLocation(), ((Event) task).getLocation());
		assertEquals(expected.getDescription(), ((Event) task).getDescription());
		assertEquals(expected.getCategory(), ((Event) task).getCategory());
		assertEquals(expected.getStatus(), ((Event) task).getStatus());
	}
	
	public void testAddEvent() throws ParseException{
		Parser parse = new Parser();
		GenericEvent task;
		Event expected = new Event();
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		Date startDate, endDate;
		
		
		task = parse.testingDeterminedStuff("add event from 1:30 pm to 1:45 pm at ivle // what");
		expected.setStartTime(format.parse("5/4/2016 13:30:00"));
		expected.setEndTime(format.parse("5/4/2016 13:45:00"));
		expected.setLocation("ivle");
		expected.setDescription("what");
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();

		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		assertEquals(expected.getLocation(), ((Event) task).getLocation());
		assertEquals(expected.getDescription(), ((Event) task).getDescription());
		
		task = parse.testingDeterminedStuff("add event from 8/4/16 to sat at ivle // what");
		expected.setStartTime(format.parse("8/4/2016 00:00:00"));
		expected.setEndTime(format.parse("9/4/2016 23:59:01"));
		expected.setLocation("ivle");
		expected.setDescription("what");
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();

		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		assertEquals(expected.getLocation(), ((Event) task).getLocation());
		assertEquals(expected.getDescription(), ((Event) task).getDescription());
		
		task = parse.testingDeterminedStuff("add event from 8/4/16 1:30 am to 12:45 pm 8/4/16");
		expected.setStartTime(format.parse("8/4/2016 01:30:00"));
		expected.setEndTime(format.parse("8/4/2016 12:45:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();

		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		
		task = parse.testingDeterminedStuff("add event from 8/4/16 1:00 to sat 12:00");
		expected.setStartTime(format.parse("8/4/2016 01:00:00"));
		expected.setEndTime(format.parse("9/4/2016 12:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();

		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		
		task = parse.testingDeterminedStuff("add event from friday 1 pm to friday 5 pm");
		expected.setStartTime(format.parse("8/4/2016 13:00:00"));
		expected.setEndTime(format.parse("8/4/2016 17:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();

		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		
		task = parse.testingDeterminedStuff("add event from friday 1:00 to 12:00");
		expected.setStartTime(format.parse("8/4/2016 01:00:00"));
		expected.setEndTime(format.parse("8/4/2016 12:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();

		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(), ((Event) task).getEndTime());	
		/*
		task = parse.testingDeterminedStuff("add event on 3 pm Friday");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("8/4/2016 15:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(),((Event) task).getEndTime());
		
		task = parse.testingDeterminedStuff("add event on 15:00 Friday");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("8/4/2016 15:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(),((Event) task).getEndTime());
		
		task = parse.testingDeterminedStuff("add event on Friday 15:00");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("8/4/2016 15:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(),((Event) task).getEndTime());
		
		task = parse.testingDeterminedStuff("add event on  31 dec 16 23:59");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("31/12/2016 23:59:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(),((Event) task).getEndTime());
		
		task = parse.testingDeterminedStuff("add event on 21:00 31/12/16");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("31/12/2016 21:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(),((Event) task).getEndTime());

		task = parse.testingDeterminedStuff("add event on 9 pm 31/12/16");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("31/12/2016 21:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(),((Event) task).getEndTime());
		
		task = parse.testingDeterminedStuff("add event on 31/12/16 9 pm");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("31/12/2016 21:00:00"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(),((Event) task).getEndTime());
		
		task = parse.testingDeterminedStuff("add event on Friday");
		expected.setStartTime(format.parse("8/4/2016 00:00:00"));
		expected.setEndTime(format.parse("8/4/2016 23:59:01"));
		startDate = ((Event) task).getStartTime();
		endDate = ((Event) task).getEndTime();
		assertEquals(expected.getStartTime(), ((Event) task).getStartTime());
		assertEquals(expected.getEndTime(),((Event) task).getEndTime());
		*/
		
		/*
		task = parse.testingDeterminedStuff("add event from friday 1:00 to 12:00");
		expected.setStartTime(format.parse("1/4/2016 01:00:00"));
		expected.setEndTime(format.parse("1/4/2016 12:00:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		
		task = parse.testingDeterminedStuff("add event from 31/12/16 00:00 to 31/12/16 23:59");
		expected.setStartTime(format.parse("31/12/2016 00:00:00"));
		expected.setEndTime(format.parse("31/12/2016 23:59:01"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		task = parse.testingDeterminedStuff("add event from 31/12/16 00 am to 31/12/16 11:59 pm");
		expected.setStartTime(format.parse("31/12/2016 00:00:00"));
		expected.setEndTime(format.parse("31/12/2016 23:59:01"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		task = parse.testingDeterminedStuff("add event from 00:00 31/12/16 to 23:59 31/12/16");
		expected.setStartTime(format.parse("31/12/2016 00:00:00"));
		expected.setEndTime(format.parse("31/12/2016 23:59:01"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		task = parse.testingDeterminedStuff("add event from 01:00 31 dec 16 to 11:59 31 dec 16");
		expected.setStartTime(format.parse("31/12/2016 01:00:00"));
		expected.setEndTime(format.parse("31/12/2016 11:59:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		task = parse.testingDeterminedStuff("add event from 01:00 31 dec 16 to 11:59 31 dec 16");
		expected.setStartTime(format.parse("31/12/2016 01:00:00"));
		expected.setEndTime(format.parse("31/12/2016 11:59:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		task = parse.testingDeterminedStuff("add event from friday 1 am to friday 12 pm");
		expected.setStartTime(format.parse("1/4/2016 01:00:00"));
		expected.setEndTime(format.parse("1/4/2016 12:00:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		
		task = parse.testingDeterminedStuff("add event from 1:30 am friday to 11:59 pm friday");
		expected.setStartTime(format.parse("1/4/2016 01:30:00"));
		expected.setEndTime(format.parse("1/4/2016 23:59:00"));
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());*/
	}
	/*
	@Test
	public void testAdd() throws ParseException {
		Parser parse = new Parser();
		Event task = new Event();
		Event expected = new Event();
		
		task = parse.testingParseCommand("add that thing by thurs at IVLE// don't forget your GF");
		//task = parse.testingParseCommand("select something");
		//task = parse.testingParseCommand("add those thing on thurs at IVLE// don't forget your GF");

		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		expected.setName("that thing");
		//expected.setStartTime(Constant.MIN_DATE);
		//expected.setEndTime(Constant.MAX_DATE);
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(format.parse("24/03/2016 23:59:00"));
		expected.setCategory(Constant.CATEGORY_DEADLINE);
		expected.setStatus(main.Event.Status.INCOMPLETE);
		expected.setDescription("don't forget your GF");
		expected.setLocation("IVLE");
		assertEquals(expected.getName(), task.getName());
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		assertEquals(expected.getCategory(), task.getCategory());
		assertEquals(expected.getStatus(), task.getStatus());
		assertEquals(expected.getDescription(), task.getDescription());
		assertEquals(expected.getLocation(), task.getLocation());
	}
	*/
	/*
	@Test
	public void testEdit() throws ParseException{
		Parser parse = new Parser();
		Event oldTask = new Event();
		Event newTask = new Event();
		Event expected = new Event();
		
		oldTask = parse.testingParseCommand("add something by 16/03/16 17:30 at IVLE // notes ");
		newTask = parse.testingParseCommand("edit that thing");
		newTask = parse.testingParseCommand("edit from 24/03/16 17:30 to 25/03/16 11:00");
		//newTask = parse.testingParseCommand("edit this thing on weds at IVLE // bring sth");
		//newTask = parse.testingParseCommand("edit // bring sth");
		//newTask = parse.testingParseCommand("edit at cinema");

		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm");

		oldTask.setName("something");
		oldTask.setStartTime(Constant.MIN_DATE);
		oldTask.setEndTime(format.parse("16/03/2016 17:30"));
		oldTask.setLocation("IVLE");
		oldTask.setDescription("notes");
		oldTask.setCategory(Constant.CATEGORY_DEADLINE);
		
		expected.setName("that thing");
		expected.setEndTime(format.parse("25/03/2016 11:00"));
		expected.setStartTime(format.parse("24/03/2016 17:30"));
		expected.setCategory(Constant.CATEGORY_EVENT);
		expected.setStatus(main.Event.Status.INCOMPLETE);
		expected.setDescription("notes");
		expected.setLocation("IVLE");
		
		assertEquals(expected.getName(), newTask.getName());
		assertEquals(expected.getStartTime(), newTask.getStartTime());
		assertEquals(expected.getEndTime(), newTask.getEndTime());
		assertEquals(expected.getCategory(), newTask.getCategory());
		assertEquals(expected.getLocation(), newTask.getLocation());
		assertEquals(expected.getDescription(), newTask.getDescription());
		assertEquals(expected.getStatus(), newTask.getStatus());

	}*/

	/*
	@Test
	public void testDelete() throws ParseException{
		Parser parse = new Parser();
		Event task = new Event();
		Event expected = new Event();
		
		task = parse.testingParseCommand("delete something from thurs 1 pm to fri 2 pm");
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		
		List<Integer> selection = new ArrayList<>();

		expected.setName("");
		expected.setStartTime(format.parse("24/03/2016 13:00"));
		expected.setEndTime(format.parse("25/03/2016 14:00"));
		expected.setCategory(null);
		expected.setStatus(Event.Status.NULL);
		expected.setDescription("");
		expected.setLocation("");
		expected.setSelection(selection);
		assertEquals(expected.getName(), task.getName());
		assertEquals(expected.getStartTime(), task.getStartTime());
		assertEquals(expected.getEndTime(), task.getEndTime());
		assertEquals(expected.getCategory(), task.getCategory());
		assertEquals(expected.getLocation(), task.getLocation());
		assertEquals(expected.getDescription(), task.getDescription());
		assertEquals(expected.getStatus(), task.getStatus());
		assertEquals(expected.getSelection(),task.getSelection());
	}
	*/
	/*
	@Test
	public void testUndetermined(){
		Parser parse = new Parser();
		Event expected = new Event();
		Event task = new Event();
		
		task = parse.testingParseCommand("block whatever on weds at JE ");
		
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm");

		List<Integer> selection = new ArrayList<>();

		expected.setName("");
		expected.setStartTime(Constant.MIN_DATE);
		expected.setEndTime(Constant.MAX_DATE);
		expected.setCategory(Constant.CATEGORY_FLOATING);
		expected.setStatus(main.Event.Status.INCOMPLETE);
		expected.setDescription("");
		expected.setLocation("IVLE");
		expected.setSelection(selection);
	}
	*/
	/*
	@Test
	public void testSelect() throws ParseException{
		Parser parse = new Parser();
		Event selected = new Event();
		Event expected = new Event();
		
		//selected = parse.testingParseCommand("select something on thurs");
		
		selected = parse.testingParseCommand("select -- uishdiashdaj");
		
		SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy HH:mm");

		List<Integer> selection = new ArrayList<>();
	
		expected.setName("something");
		expected.setStartTime(format.parse("24/3/2016 00:00"));
		expected.setEndTime(format.parse("24/3/2016 23:59"));
		expected.setCategory(Constant.CATEGORY_EVENT);
		expected.setStatus(main.Event.Status.INCOMPLETE);
		expected.setDescription("");
		expected.setLocation("");
		expected.setSelection(selection);
		assertEquals(expected.getName(), selected.getName());
		assertEquals(expected.getStartTime(), selected.getStartTime());
		assertEquals(expected.getEndTime(), selected.getEndTime());
		assertEquals(expected.getCategory(), selected.getCategory());
		assertEquals(expected.getLocation(), selected.getLocation());
		assertEquals(expected.getDescription(), selected.getDescription());
		assertEquals(expected.getStatus(), selected.getStatus());
		assertEquals(expected.getSelection(),selected.getSelection());
	}
	*/
}
```
