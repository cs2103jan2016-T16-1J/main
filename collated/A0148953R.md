# A0148953R
###### /src/command/Add.java
``` java
 */
public class Add implements Command{

	GenericEvent modifiedEvent;
	State completeState;

	/**
	 * Add class constructor
	 * @param modifiedEvent the event that will be added
	 */
	public Add(GenericEvent modifiedEvent){
		this.modifiedEvent = modifiedEvent;
	}

	/**
	 * Inherited from the Command interface
	 * execute will add the event to its corresponding list based on status
	 * @param completeState the state of all the tasks in the program
	 * @throws JSONException 
	 * @throws IOException 
	 */
	public State execute(State completeState) throws IOException, JSONException{
		
		this.completeState = completeState;
		
		if(!isNewEventValid()){
			return completeState;
		}
		
		switch (modifiedEvent.getStatus()){
		case COMPLETE:
			addToCompleteList();
			break;
		case INCOMPLETE:
			addToIncompleteList();
			break;			
		case UNDETERMINED:
			addToUndeterminedList();
			break;
		}
		
		/*to select the previously added or reserved event*/
		if(!completeState.hasErrorMessage){
			completeState.setOneSelectedEvent(modifiedEvent);
			
			updatedDisplayedEvents();
		}
		
		return completeState;
	}


	private boolean isNewEventValid(){
		if(null == modifiedEvent){
			completeState.setStatusMessage(State.MESSAGE_PARSE_ERROR);
			completeState.hasErrorMessage = true;
			return false;
		}
		
		return true;
	}
	/**
	 * adds the given task to the completed list in State
	 */
	public void addToCompleteList(){
		completeState.addToCompletedList((Event)modifiedEvent);
	}

	/**
	 * adds the given task to the incomplete list in State
	 */
	public void addToIncompleteList(){
		completeState.addToIncompletedList((Event)modifiedEvent);
	}

	public void addToUndeterminedList(){
		
		if(modifiedEvent.getCategory() == Category.FLOATING){
			
			completeState.addToUndeterminedList((ReservedEvent) modifiedEvent);
		} else{
			
			completeState.setStatusMessage(State.MESSAGE_ATTEMPTED_RESERVE_WITH_ADD);
			completeState.hasErrorMessage = true;

		}
	}
	
	/**
	 * updates the displayedEvents with new information
	 */
	public void updatedDisplayedEvents(){
		completeState.displayedEvents.clear();
		completeState.displayedEvents.addAll(completeState.getCompletedList());
		completeState.displayedEvents.addAll(completeState.getIncompletedList());
		completeState.displayedEvents.addAll(completeState.getReservedList());
		completeState.displayedEvents.addAll(completeState.getUndeterminedList());
	}

}
```
###### /src/command/ChangeTab.java
``` java
 */
public class ChangeTab implements Command{
	Status newTab;
	State completeState;
	
	public ChangeTab(Status newTab){
		this.newTab = newTab;
	}
	
	public State execute(State completeState) throws IOException, JSONException{
		this.completeState = completeState;
		
		completeState.setSelectedTab(newTab);
		filterSingleSelectedEventByTab();
		completeState.filterListsByTab();
		return completeState;
	}
	
	public boolean filterSingleSelectedEventByTab(){
		if(!completeState.hasSingleEventSelected()){
			return false;
		}
		completeState.filteredSelectedEvent = completeState.selectedEvent;
		
		if(completeState.filteredSelectedEvent.getStatus().equals(completeState.getSelectedTab())){
			completeState.setFilterStatus(State.ONE_EVENT_SELECTED);

			return true;
		}
		
		completeState.setFilterStatus(State.NO_EVENTS_SELECTED);
		completeState.filteredSelectedEvent = null;

		return false;
	}	
	
}
```
###### /src/command/Command.java
``` java
 */
public interface Command {

	/**
	 * execute must be inherited by each command. This method invokes the command action
	 * @param completeState the state of all tasks in the program
	 * @return the state of all tasks in the program
	 * @throws JSONException 
	 * @throws IOException 
	 */
	public State execute(State completeState) throws IOException, JSONException;
	
}
```
###### /src/command/Complete.java
``` java
 */
public class Complete implements Command{

	GenericEvent modifiedEvent;
	State completeState;

	public Complete(){}
	

	/**
	 * Inherited from the Command interface
	 * execute will edit the event from its corresponding list based on status
	 * @param completeState the state of all the tasks in the program
	 */
	public State execute(State completeState){
		this.completeState = completeState;
		
		if((!checkSelectedEvent()) || (!checkEventType())){
			return completeState;
		}
		
		deleteFromIncompleteList();
		
		modifiedEvent.setStatus(Status.COMPLETE);
		
		addToCompleteList();
		
		return completeState;
		
	}
	
	private void deleteFromIncompleteList(){
		Command deleting = new Delete(modifiedEvent);
		try {
			completeState = deleting.execute(completeState);
		} catch (IOException | JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private void addToCompleteList(){
		Command adding  = new Add(modifiedEvent);
		try {
			completeState = adding.execute(completeState);

		} catch (IOException | JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}

	public boolean checkEventType(){
		if(!(modifiedEvent instanceof Event)){
			completeState.setErrorMessage(State.MESSAGE_COMPLETE_INVALID_EVENT_TYPE);
			return false;
		}
		if(modifiedEvent.getStatus() != Status.INCOMPLETE){
			completeState.setErrorMessage(State.MESSAGE_COMPLETE_INVALID_EVENT_STATUS);
			return false;
		}
		
		return true;
	}
	
	public boolean checkSelectedEvent(){
		
		if(!completeState.hasSingleEventSelected()){
			completeState.setErrorMessage(State.MESSAGE_EVENT_NOT_FOUND);
			return false;
		}
		
		modifiedEvent = completeState.getSingleSelectedEvent();

		
		return true;
		
	}
}
```
###### /src/command/Confirm.java
``` java
 */
public class Confirm implements Command{

	GenericEvent originalEvent;
	Event newEvent;
	Date startTime;
	Date endTime;
	String stringStartTime;
	String stringEndTime;
	State completeState;
	int index;

	/**
	 * Edit Event constructor
	 * @param originalEvent the original event located in completeState
	 * @param editedEvent new information in the form of an Event object that will replace the original event
	 */
	
	public Confirm(int index){
		this.index = index - 1;
	}

	public Confirm(Date startTime, Date endTime, String stringStartTime, String stringEndTime){
		this.startTime = startTime;
		this.endTime = endTime;
		this.stringStartTime = stringStartTime;
		this.stringEndTime = stringEndTime;
		this.index = -1;
	}
	
	private boolean checkForSelectedEvent(){
		if(completeState.hasSingleEventFiltered()){
			originalEvent = completeState.getSingleFilteredEvent();
		}
		
		return true;
	}
	
	private boolean checkEventType(){
		if(!(originalEvent instanceof ReservedEvent)){
			completeState.setErrorMessage(State.MESSAGE_INVALID_CONFIRM);
			return false;
		}
		return true;
	}
	
	/*	public Event(String name, String location, String description, Category category, Date startTime, Date endTime,
			String stringStartTime,String stringEndTime, Status status){*/
	private void confirmTimes(){
		newEvent = new Event(originalEvent.getName(), originalEvent.getLocation(), originalEvent.getDescription(), originalEvent.getCategory(), startTime, endTime, stringStartTime, stringEndTime, Status.INCOMPLETE);
		switchObjectTypes();
	}
	
	public void switchObjectTypes(){
		
		Command delete = new Delete(null);
		Command add = new Add(newEvent);
		
		try {
			completeState = delete.execute(completeState);
			completeState = add.execute(completeState);
		} catch (IOException | JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	private boolean getTimesOfSelectedIndex(){
		int numberOfReservedTimes = ((ReservedEvent)originalEvent).getReservedTimes().size();
		
		if((index < 0) || (index > numberOfReservedTimes)){
			completeState.setErrorMessage(State.MESSAGE_INVALID_INDEX);
			return false;
		}
		
		startTime = ((ReservedEvent)originalEvent).getReservedTimes().get(index).getStartTime();
		endTime = ((ReservedEvent)originalEvent).getReservedTimes().get(index).getEndTime();
		stringStartTime = startTime.toString();
		stringEndTime = endTime.toString();

		
		return true;
	}
	
	public State execute(State completeState){
		this.completeState = completeState;
		
		if(!checkForSelectedEvent()){
			completeState.setStatusMessage(State.MESSAGE_EVENT_NOT_FOUND);
			return completeState;
		}
		
		if(!checkEventType()){
			return completeState;
		}
		
		if(index != -1){
			getTimesOfSelectedIndex();
		}
		
		if(!completeState.hasErrorMessage){
			confirmTimes();
		}
		
		
		return completeState;
	}
		
}
```
###### /src/command/Delete.java
``` java
 */
public class Delete implements Command{

	GenericEvent selectedParameters;
	State completeState;

	/**
	 * Delete class constructor. 
	 * @param modifiedEvent the event that will be deleted
	 */
	public Delete(GenericEvent selectedParameters){
		this.selectedParameters = selectedParameters;
	}
	
	/**
	 * Inherited from the Command interface
	 * execute will delete the event from its corresponding list based on status
	 * If two identical instances of the class are found in the list, only one is deleted
	 * @param completeState the state of all the tasks in the program
	 * @throws JSONException 
	 */
	public State execute(State completeState) throws JSONException{
		
		this.completeState = completeState;
		
		if(!hasDeleteParameters()){
			completeState.updateDisplayedEvents();
			return completeState;
		}
		
		ArrayList<GenericEvent> allEvents = completeState.getAllEvents();
		ArrayList<GenericEvent> eventsToDelete = getMatchingEvents(allEvents);

		
		if(!hasMatchingEvents(eventsToDelete)){
			return completeState;
		}
		
		deleteFromSelectedEvents(eventsToDelete);
		
		deleteMatchedEvents(eventsToDelete);
		
		completeState.updateDisplayedEvents();

		return completeState;
	}
	
	private boolean hasDeleteParameters(){
		if(null == selectedParameters){
			deleteStateSelectedEvent();
			return false;		
		}
		if(selectedParameters.hasSelection()){
			deleteStateSelectedEvent();
			return false;
		}
		
		return true;
	}
	
	private void deleteFromSelectedEvents(ArrayList<GenericEvent> eventsToDelete){
		if((completeState.hasSingleEventSelected()) && (isMatchingEvent(completeState.getSingleSelectedEvent()))){
			completeState.clearSelections();
		}
		if(completeState.hasMultipleEventSelected()){
			for(GenericEvent e : completeState.getAllSelectedEvents()){
				if(isMatchingEvent(e)){
					completeState.selectedEvents.remove(e);
				}
			}
		}
	}

	
	private void deleteStateSelectedEvent(){
		if(completeState.hasSingleEventSelected()){
			deleteFromCorrespondingArray(completeState.getSingleSelectedEvent());
			completeState.clearSelections();
		}
		else if(completeState.hasMultipleEventSelected()){
			evaluateSelectedEvents();
		}		
		else{
			completeState.setErrorMessage(State.MESSAGE_NO_SELECTED_EVENT);
		}

	}

	private void evaluateSelectedEvents(){
		if(null == selectedParameters){
			deleteFromMultipleSelectedEvents();
			completeState.clearSelections();
		}
		else{
			int index = selectedParameters.getSelection().get(0) - 1;
			
			if((index < 0) || (index > completeState.selectedEvents.size())){
				completeState.setErrorMessage(State.MESSAGE_INVALID_INDEX);
			}
			else{
				deleteFromCorrespondingArray(completeState.getAllSelectedEvents().get(index));
				completeState.selectedEvents.remove(index);
				
			}
		}
	}
	
	private void deleteFromMultipleSelectedEvents() {
		for(GenericEvent e : completeState.getAllSelectedEvents()){
			deleteFromCorrespondingArray(e);
		}
	}
	
	private void deleteMatchedEvents(ArrayList<GenericEvent> eventsToDelete){
		for(GenericEvent e: eventsToDelete ){
			deleteFromCorrespondingArray(e);
		}
	}
	
	/**
	 * Deletes the event from the corresponding array, which is based on the event's status
	 * @param e
	 */
	private void deleteFromCorrespondingArray(GenericEvent e){
		switch (e.getStatus()){
		case COMPLETE:
			removeFromCompleteList((Event)e);
			break;
		case INCOMPLETE:
			removeFromIncompleteList((Event)e);
			break;
		case UNDETERMINED:
			removeFromUndeterminedList((ReservedEvent)e);
			break;
			
		}
	}
	
	private void removeFromCompleteList(Event e){
		completeState.completedEvents.remove(e);
	}
	
	private void removeFromIncompleteList(Event e){
		completeState.incompletedEvents.remove(e);
	}
	
	private void removeFromUndeterminedList(ReservedEvent e){
		if(e.getCategory().equals(Category.FLOATING)){
			completeState.undeterminedEvents.remove(e);

		}
		else{
			completeState.reservedEvents.remove(e);
		}
	}
	
	private boolean hasMatchingEvents(ArrayList<GenericEvent> eventsToDelete){
		if(eventsToDelete.isEmpty()){
			completeState.setStatusMessage(State.MESSAGE_EVENT_NOT_FOUND);
			completeState.hasErrorMessage = true;
			return false;
		}
		
		return true;
	}
	
	private ArrayList<GenericEvent> getMatchingEvents(ArrayList<GenericEvent> allEvents){
		ArrayList<GenericEvent> matchingEvents = new ArrayList<GenericEvent>();
		
		for(GenericEvent e: allEvents){
			if(isMatchingEvent(e)){
				matchingEvents.add(e);				
			}
		}
		
		return matchingEvents;
	}
	
	
	private boolean isMatchingEvent(GenericEvent currentEvent){
		boolean isMatch = true;
				
		isMatch = isStringMatching(currentEvent.getName(), selectedParameters.getName()) &&
				isStringMatching(currentEvent.getLocation(), selectedParameters.getLocation()) &&
				isStringMatching(currentEvent.getDescription(), selectedParameters.getDescription())
				//&& isCategoryMatching(currentEvent.getCategory(), selectedParameters.getCategory())
				//&& isTimeMatching(currentEvent.getStartTime(), currentEvent.getEndTime(), selectedParameters.getStartTime(), selectedParameters.getEndTime())
				//&& isStatusMatching(currentEvent.getStatus(), selectedParameters.getStatus())
				;
		
		
		
		return isMatch;
		
	}
	
	private boolean isStatusMatching(GenericEvent.Status eventStatus, GenericEvent.Status paramStatus){
		if(paramStatus == Constant.STATUS_NULL){
			return true;
		}
		return eventStatus == paramStatus;
		
	}
	
	private boolean isCategoryMatching(GenericEvent.Category eventCategory, GenericEvent.Category paramCategory){
		if(paramCategory == Constant.CATEGORY_NULL){
			return true;
		}
		return eventCategory == paramCategory;
	}
	
	private boolean isStringMatching(String eventString, String paramString){
		boolean isMatch = true;
		
		if(paramString.equals(Constant.EMPTY_STRING)){
			return isMatch;
		}
		
		isMatch = eventString.toLowerCase().contains(paramString.toLowerCase());
		
		return isMatch;
	}
	
	private boolean isTimeMatching(Date eventStart, Date eventEnd, Date paramStart, Date paramEnd){
		boolean isStartMatch;
		boolean isEndMatch;
		
		isStartMatch = isStartTimeWithinRange(eventStart, paramStart, paramEnd);
		if(paramStart.equals(Constant.MIN_DATE)){
			isStartMatch = true;
		}
		
		isEndMatch = isEndTimeWithinRange(eventEnd, paramStart, paramEnd);
		
		if(paramStart.equals(Constant.MAX_DATE)){
			isEndMatch = true;
		}
		
		
		return isStartMatch && isEndMatch;
	}
	
	public boolean isStartTimeWithinRange(Date eventStart, Date paramStart, Date paramEnd){
		
		return ((eventStart.getTime() >= paramStart.getTime()) && (eventStart.getTime() <= paramEnd.getTime()));
	}

	private boolean isEndTimeWithinRange(Date eventEnd, Date paramStart, Date paramEnd){
		
		return ((eventEnd.getTime() >= paramStart.getTime()) && (eventEnd.getTime() <= paramEnd.getTime()));
	}

}

```
###### /src/command/Edit.java
``` java
 */
public class Edit implements Command{

	GenericEvent originalEvent;
	GenericEvent selectedParameters;
	State completeState;

	/**
	 * Edit Event constructor
	 * @param originalEvent the original event located in completeState
	 * @param editedEvent new information in the form of an Event object that will replace the original event
	 */

	public Edit(GenericEvent event){
		this.selectedParameters = event;
	}
	
	private boolean checkForSelectedEvent(){
		if(completeState.hasSingleEventSelected()){
			originalEvent = completeState.getSingleSelectedEvent();
			return true;
		}
		
		return false;
	}

	/**
	 * Inherited from the Command interface
	 * execute will edit the event from its corresponding list based on status
	 * @param completeState the state of all the tasks in the program
	 */
	public State execute(State completeState){
		this.completeState = completeState;
		
		if(!checkForSelectedEvent()){
			completeState.setStatusMessage(State.MESSAGE_EVENT_NOT_FOUND);
			return completeState;
		}
		

		if(checkObjectTypes()){
			updateGenericEvent();
		}
		
		completeState.updateDisplayedEvents();

		return completeState;
	}
	
	public boolean checkObjectTypes(){
		//if the objects are not equal
		if(!selectedParameters.getClass().equals(originalEvent.getClass())){
			switchObjectTypes();
			return false;
		}
		
		return true;
	}
	
	public void switchObjectTypes(){
		Command delete;
		Command add;
		if(selectedParameters instanceof ReservedEvent){
			ReservedEvent newEvent = switchToReservedParameters();

			delete = new Delete(null);
			add = new Add(newEvent);
		}
		else{
			Event newEvent = switchToEventParameters();		
			delete = new Delete(null);
			add = new Add(newEvent);
		}
		
		try {
			completeState = delete.execute(completeState);
			completeState = add.execute(completeState);
		} catch (IOException | JSONException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	public ReservedEvent switchToReservedParameters(){
		ReservedEvent newEvent = new ReservedEvent();
		newEvent.setName(checkNameParameter(originalEvent.getName()));
		newEvent.setLocation(checkLocationParameter(originalEvent.getLocation()));
		newEvent.setDescription(checkDescriptionParameter(originalEvent.getDescription()));
		newEvent.setCategory(checkCategoryParameter(originalEvent.getCategory()));
		newEvent.setStatus(Status.UNDETERMINED);
		
		newEvent.setReservedTimes(((ReservedEvent)originalEvent).getReservedTimes());

		
		return newEvent;
	}
	
	public Event switchToEventParameters(){
		Event newEvent = new Event();
		newEvent.setName(checkNameParameter(originalEvent.getName()));
		newEvent.setLocation(checkLocationParameter(originalEvent.getLocation()));
		newEvent.setDescription(checkDescriptionParameter(originalEvent.getDescription()));
		newEvent.setCategory(checkCategoryParameter(originalEvent.getCategory()));
		newEvent.setStatus(Status.INCOMPLETE);
		
		newEvent.setStartTime(checkStartTimeParameter(Constant.MIN_DATE));
		
		newEvent.setEndTime(checkEndTimeParameter(Constant.MAX_DATE));

		return newEvent;
	}
	
	public String checkNameParameter(String original){
		if(!selectedParameters.getName().equals(Constant.EMPTY_STRING)){
			return selectedParameters.getName();
		}		
		return original;
	}

	public String checkLocationParameter(String original){
		if(!selectedParameters.getLocation().equals(Constant.EMPTY_STRING)){
			return selectedParameters.getLocation();
		}
		return original;
	}
	
	public String checkDescriptionParameter(String original){
		if(!selectedParameters.getDescription().equals(Constant.EMPTY_STRING)){
			return selectedParameters.getDescription();
		}		
		return original;
	}
	
	public Category checkCategoryParameter(Category original){
		if(!selectedParameters.getCategory().equals(Category.FLOATING)){
			return selectedParameters.getCategory();
		}		
		return original;
	}
	
	public Status checkStatusParameter(Status original){
		if(!selectedParameters.getStatus().equals(Status.INCOMPLETE)){
			return selectedParameters.getStatus();
		}
		return original;
	}

	public Date checkStartTimeParameter(Date original){
		if(!((Event)selectedParameters).getStartTime().equals(Constant.MIN_DATE)){
			return ((Event)selectedParameters).getStartTime();
		}
		return original;
	}
	
	public Date checkEndTimeParameter(Date original){
		if(!((Event)selectedParameters).getEndTime().equals(Constant.MAX_DATE)){
			return ((Event)selectedParameters).getEndTime();
		}
		return original;
	}
	
	public ArrayList<TimePair> checkReservedTimesParameter(ArrayList<TimePair> original){
		if(!((ReservedEvent)selectedParameters).getReservedTimes().isEmpty()){
			return ((ReservedEvent)selectedParameters).getReservedTimes();
		}
		return original;
	}
	
	public void updateGenericEvent(){
		originalEvent.setName(checkNameParameter(originalEvent.getName()));
		originalEvent.setLocation(checkLocationParameter(originalEvent.getLocation()));
		originalEvent.setDescription(checkDescriptionParameter(originalEvent.getDescription()));
		if(((Event)selectedParameters).getStartTime().equals(Constant.MIN_DATE) && !((Event)selectedParameters).getEndTime().equals(Constant.MAX_DATE) ){
			originalEvent.setCategory(Category.DEADLINE);

		}
		else{
			originalEvent.setCategory(checkCategoryParameter(originalEvent.getCategory()));
		}
		originalEvent.setStatus(checkStatusParameter(originalEvent.getStatus()));
		/*if(!selectedParameters.getSelection().isEmpty()){
			originalEvent.setSelection(selectedParameters.getSelection());
		}*/
		
		if(originalEvent instanceof Event){
			updateEvent();
		}
		if(originalEvent instanceof ReservedEvent){
			updateReservedEvent();
		}
		
		completeState.setOneSelectedEvent(originalEvent);

	}
	
	public void updateEvent(){
		((Event)originalEvent).setStartTime(((Event)selectedParameters).getStartTime());
			
		((Event)originalEvent).setEndTime(checkEndTimeParameter(((Event)originalEvent).getEndTime()));
		
	}
	
	public void updateReservedEvent(){
		((ReservedEvent)originalEvent).setReservedTimes(((ReservedEvent)originalEvent).getReservedTimes());
		
		
	}
	
	
}
```
###### /src/command/Reserve.java
``` java
 */
public class Reserve implements Command{

	GenericEvent modifiedEvent;
	State completeState;

	/**
	 * Add class constructor
	 * @param modifiedEvent the event that will be added
	 */
	public Reserve(GenericEvent modifiedEvent){
		this.modifiedEvent = modifiedEvent;
	}

	/**
	 * Inherited from the Command interface
	 * execute will add the event to its corresponding list based on status
	 * @param completeState the state of all the tasks in the program
	 * @throws JSONException 
	 * @throws IOException 
	 */
	public State execute(State completeState) throws IOException, JSONException{
		
		this.completeState = completeState;
		
		if(!isNewEventValid()){
			return completeState;
		}
		
		switch (modifiedEvent.getStatus()){
			case UNDETERMINED:
				addToUndeterminedList();
				break;
			default:
				completeState.setStatusMessage(State.MESSAGE_INVALID_RESERVED);
				completeState.hasErrorMessage = true;

				break;
							
			}
		
		if(!completeState.hasErrorMessage){
			completeState.setOneSelectedEvent(modifiedEvent);
			
			completeState.updateDisplayedEvents();
		}
		
		return completeState;
	}


	private boolean isNewEventValid(){
		if(null == modifiedEvent){
			completeState.setStatusMessage(State.MESSAGE_PARSE_ERROR);
			return false;
		}
		
		return true;
	}
	
	public void addToUndeterminedList(){

		if(modifiedEvent.getCategory() == Category.FLOATING){
			
			completeState.setStatusMessage(State.MESSAGE_ATTEMPTED_ADD_WITH_RESERVE);
			completeState.hasErrorMessage = true;

		} else{
			completeState.addToReservedList((ReservedEvent)modifiedEvent);
		}

	}


}
```
###### /src/command/Select.java
``` java
 */
public class Select implements Command{

	Event selectedParameters;
	State completeState;
	
	boolean selectByIndex;
	int index;
	
	public Select(Event selectedParameters){
		this.selectedParameters = selectedParameters;
		selectByIndex = false;

	}
	
	public Select(int index){
		this.index = index -1;
		selectByIndex = true;
	}
	
	@Override
	public State execute(State completeState) throws IOException, JSONException {
		// TODO Auto-generated method stub
		this.completeState = completeState;
				
		ArrayList<GenericEvent> allEvents = completeState.getAllEvents();
		///for each event in allEvents check if it matches selectedParameters
		//if the event does, clone it and add it to completeState.selectedEvents
		if(selectByIndex){
			selectViaIndex();
		}
		else{
			getMatchingEvents(allEvents);
			checkSelectionStatus();
		}
		return completeState;
	}

	private boolean selectViaIndex(){
		//if there are no events selected or if there is already only one event selected, don't do anything
		if(!completeState.hasEventSelected() || completeState.hasSingleEventSelected()){
			return false;
		}

		//if an invalid index is provided
		if(index > completeState.selectedEvents.size()){
			completeState.setStatusMessage(State.MESSAGE_INVALID_INDEX);
			completeState.hasErrorMessage = true;
			return false;
		}
		
		completeState.setOneSelectedEvent(completeState.selectedEvents.get(index));
		
		completeState.selectedEvents.clear();
		completeState.selectedEvents.add(completeState.selectedEvent);
		completeState.setSelectionStatus(State.ONE_EVENT_SELECTED);
		
		return true;
	}
	
	private void checkSelectionStatus(){
		
		if(completeState.selectedEvents.isEmpty() == true){
			completeState.setSelectionStatus(State.NO_EVENTS_SELECTED);
			completeState.setFilterStatus(State.NO_EVENTS_SELECTED);
		}
		else if(completeState.selectedEvents.size() > 1){
			completeState.setSelectionStatus(State.MULTIPLE_EVENTS_SELECTED);
			completeState.setFilterStatus(State.MULTIPLE_EVENTS_SELECTED);
		}
		else{
			completeState.setOneSelectedEvent(completeState.selectedEvents.get(0));
		}
	}	

	private void getMatchingEvents(ArrayList<GenericEvent> allEvents){
		completeState.clearSelections();
	
		for(GenericEvent e: allEvents){
			if(isMatchingEvent(e)){
				completeState.selectedEvents.add(e);
				
			}
		}	
	}
	
	private boolean isMatchingEvent(GenericEvent currentEvent){
		boolean isMatch = true;
				
		isMatch = isStringMatching(currentEvent.getName(), selectedParameters.getName()) &&
				isStringMatching(currentEvent.getLocation(), selectedParameters.getLocation()) &&
				isStringMatching(currentEvent.getDescription(), selectedParameters.getDescription())
				//&&
				//isCategoryMatching(currentEvent.getCategory(), selectedParameters.getCategory()) &&
				//isTimeMatching(currentEvent.getStartTime(), currentEvent.getEndTime(), selectedParameters.getStartTime(), selectedParameters.getEndTime())
				&& isStatusMatching(currentEvent.getStatus(), completeState.getSelectedTab())
				;
						
		return isMatch;
		
	}
	
	private boolean isCategoryMatching(GenericEvent.Category eventCategory, GenericEvent.Category paramCategory){
		if(paramCategory.equals(Constant.CATEGORY_NULL)){
			return true;
		}
		return eventCategory == paramCategory;
		
	}
	
	private boolean isStatusMatching(GenericEvent.Status eventStatus, GenericEvent.Status paramStatus){
		if(paramStatus.equals(Constant.STATUS_NULL)){
			return true;
		}
		return eventStatus == paramStatus;
		
	}
	
	private boolean isStringMatching(String eventString, String paramString){
		boolean isMatch = true;
		
		if(paramString.equals(Constant.EMPTY_STRING)){
			return isMatch;
		}
		
		isMatch = eventString.toLowerCase().contains(paramString.toLowerCase());
		
		return isMatch;
	}
	
	private boolean isTimeMatching(Date eventStart, Date eventEnd, Date paramStart, Date paramEnd){
		boolean isStartMatch;
		boolean isEndMatch;
		
		isStartMatch = isStartTimeWithinRange(eventStart, paramStart, paramEnd);
		if(paramStart.equals(Constant.MIN_DATE)){
			isStartMatch = true;
		}
		
		isEndMatch = isEndTimeWithinRange(eventEnd, paramStart, paramEnd);
		
		if(paramStart.equals(Constant.MAX_DATE)){
			isEndMatch = true;
		}
		
		
		return isStartMatch && isEndMatch;
	}
	
	public boolean isStartTimeWithinRange(Date eventStart, Date paramStart, Date paramEnd){
		
		return ((eventStart.getTime() >= paramStart.getTime()) && (eventStart.getTime() <= paramEnd.getTime()));
	}
	
	private boolean isEndTimeWithinRange(Date eventEnd, Date paramStart, Date paramEnd){
		
		return ((eventEnd.getTime() >= paramStart.getTime()) && (eventEnd.getTime() <= paramEnd.getTime()));
	}
	


}
```
###### /src/command/Undo.java
``` java
 */
public class Undo implements Command{
	State completeState;

	@Override
	public State execute(State completeState) throws IOException, JSONException {
		// TODO Auto-generated method stub
		
		this.completeState = completeState;
		
		if(completeState.eventHistory.isEmpty() || completeState.eventHistory.size() < 2){
			return completeState;
		}
		
		completeState.eventHistory.pop();
		
		return completeState.eventHistory.pop();
	}

}
```
###### /src/controller/Controller.java
``` java
 */
public class Controller{
	
	private State completeState;
	private Parser parser;
	private Storage storage;

	/**
	 * Default Controller constructor
	 */
	public Controller() {
		parser = new Parser();
		storage = new Storage();
		storage.createFile(Storage.storageFile);
		completeState = storage.readStorage(Storage.storageFile);
	}
	
	public State getCompleteState() {
		return completeState;
	}
	
	//for testing use only
	public void setCompleteState(State state){
		this.completeState = state;
	}
	
	/**
	 * This method is invoked from the UI when the user gives a command
	 * It calls the parser and receives a Command object in return.
	 * The Command is then executed
	 * @param commandText
	 * @throws JSONException 
	 * @throws IOException 
	 */
	public State executeCommand(String commandText, String directory) throws IOException, JSONException{
		completeState.clearStatusMessage();
		Command userCommand;
		userCommand = parser.parseCommand(commandText); //parser should return Command
		if(null == userCommand){
			completeState.setStatusMessage(State.MESSAGE_PARSE_ERROR);
			return completeState;
		}
		
		completeState = userCommand.execute(completeState);
		assert isValidCommand(userCommand);
		//assert false;
		storage.stateToStorage(completeState, directory);
		pushToEventHistory();
		
		return completeState;
	}
	
	/**
	 * Pushes the current state to the event history. This method is used to maintain history for the Undo Command
	 */
	private void pushToEventHistory(){
		State newState = new State(completeState);
		
		completeState.eventHistory.push(newState);
		
	}
	
	/**
	 * Checks that the command that has been provided is valid
	 * @param userCommand
	 * @return
	 */
	private boolean isValidCommand(Command userCommand){
		if((userCommand != null) && (completeState.getStatusMessage() != State.MESSAGE_PARSE_ERROR)){
			return true;
		}		
		return false;
	}		
	
	/**
	 * Returns all the events in the State ordered by their similarity to the String userInput
	 * This method should be called from the UI when the user is typing, so that they are able to receive recommendations on event names
	 * @param userInput
	 * @return matches
	 */
	public ArrayList<GenericEvent> bestMatchingOrder(String userInput){
		ArrayList<GenericEvent> allEvents = completeState.getAllEvents();
		
		HashMap<GenericEvent, Integer> distanceMap = new HashMap<GenericEvent, Integer>();
		
		for(GenericEvent e : allEvents){
			distanceMap.put(e, levenshteinDistance(userInput, e.getName()));
			
		}
		
		ArrayList<GenericEvent> matches = sortByValues(distanceMap);
		
		
		return matches;
	}
	
	/**
	 * Sorts the already levenshtein-calculated array by levenshtein distance.
	 * The more similar event names should be at the beginning of the array
	 * @param map
	 * @return
	 */
	private ArrayList<GenericEvent> sortByValues(HashMap<GenericEvent, Integer> map){
		
	       List list = new LinkedList(map.entrySet());
	       // Defined Custom Comparator here
	       Collections.sort(list, new Comparator() {
	    	   
	            public int compare(Object o1, Object o2) {
	               return ((Comparable) ((Map.Entry) (o1)).getValue())
	                  .compareTo(((Map.Entry) (o2)).getValue());
	            }
	       });


	       ArrayList<GenericEvent> matches = new ArrayList<GenericEvent>();
	       for (Iterator it = list.iterator(); it.hasNext();) {
	              Map.Entry entry = (Map.Entry) it.next();
	              matches.add((GenericEvent)entry.getKey());
	       } 
	       return matches;
	}
	
	/**
	 * Calculates the levenshtein distance between two strings
	 * Levenshtein distance determines the similarity between two strings
	 * @param stringOne
	 * @param stringTwo
	 * @return the levenshteinDistance
	 */
    private int levenshteinDistance(String stringOne, String stringTwo) {
        stringOne = stringOne.toLowerCase();
        stringTwo = stringTwo.toLowerCase();
        
        int [] costs = new int [stringTwo.length() + 1];
        
        for (int j = 0; j < costs.length; j++){
            costs[j] = j;
        }
        
        for (int i = 1; i <= stringOne.length(); i++) {
            costs[0] = i;
            int nw = i - 1;
            for (int j = 1; j <= stringTwo.length(); j++) {
                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), stringOne.charAt(i - 1) == stringTwo.charAt(j - 1) ? nw : nw + 1);
                nw = costs[j];
                costs[j] = cj;
            }
        }
        return costs[stringTwo.length()];
    }
	
	
	
}
```
###### /src/main/Event.java
``` java
 */
public class Event extends GenericEvent{

	private Date startTime;
	private Date endTime;
	private String stringStartTime;
	private String stringEndTime;
	
	/**
	 * Default Constructor for Event
	 */
	public Event(){
		super();
		startTime = Constant.MIN_DATE; 
		endTime = Constant.MAX_DATE;
		stringStartTime = "";
		stringEndTime = "";
	}
	
	/**
	 * Constructor which creates Event using provided parameters
	 * @param name
	 * @param location
	 * @param description
	 * @param category
	 * @param startTime
	 * @param endTime
	 * @param stringStartTime
	 * @param stringEndTime
	 * @param status
	 */
	public Event(String name, String location, String description, Category category, Date startTime, Date endTime,
			String stringStartTime,String stringEndTime, Status status){
		super(name, location, description, category, status);
		this.startTime = startTime;
		this.endTime = endTime;
		this.stringStartTime = stringStartTime;
		this.stringEndTime = stringEndTime;
	}

	/**
	 * Sets the startTime of the Event
	 * @param startTime
	 */
	public void setStartTime(Date startTime){
		if(startTime == Constant.MIN_DATE){
			this.stringStartTime = "";
		} else{
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
			this.stringStartTime = sdf.format(startTime);
		}
		this.startTime = startTime;
	}
	
	/**
	 * Returns the startTime of the Event in Date format
	 * @return
	 */
	public Date getStartTime(){
		return this.startTime;
	}
	
	/**
	 * Sets the endTime of the Event
	 * @param endTime
	 */
	public void setEndTime(Date endTime){
		if(endTime == Constant.MAX_DATE){
			this.stringEndTime = "";
		} else{
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
			this.stringEndTime = sdf.format(endTime);
		}
		this.endTime = endTime;
	}
	
	/**
	 * Returns the endTime of the Event in Date format
	 * @return
	 */
	public Date getEndTime(){
		return this.endTime;
	}
	
	/**
	 * Returns the endTime in string format
	 * @return
	 */
	public String getEndTimeString(){
		return this.stringEndTime;
	}
	
	/**
	 * Returns the startTime in string format
	 * @return
	 */
	public String getStartTimeString(){
		return this.stringStartTime;
	}

	/**
	 * Returns a clone of the Event
	 * @return
	 */
	public Event getClone(){
		Event clonedEvent = new Event(this.getName(), this.getLocation(), this.getDescription(), this.getCategory(), 
				this.getStartTime(), this.getEndTime(), this.getStartTimeString(), this.getEndTimeString(), this.getStatus());
		
		return clonedEvent;
	}
	
	

	
}
```
###### /src/main/GenericEvent.java
``` java
 */
public abstract class GenericEvent {

	public enum Status {
		NULL, INCOMPLETE, UNDETERMINED, COMPLETE
	}

	public enum Category {
		NULL, DEADLINE, EVENT, FLOATING
	}

	private String name;
	private String description;
	private Category category;
	private String location;
	private Status status;
	private List<Integer> selection;
	
	public GenericEvent(){
		name = Constant.EMPTY_STRING;
		location = Constant.EMPTY_STRING;
		description = Constant.EMPTY_STRING;
		category = Category.FLOATING;
		status = Status.INCOMPLETE;
		selection = new ArrayList<>();
	}
	
	public GenericEvent(String name, String location, String description, Category category, Status status){
		this.name = name;
		this.location = location;
		this.description = description;
		this.category = category;
		this.status = status;
		
	}
	
	public void setName(String name){
		this.name = name;
	}
	
	public String getName(){
		return this.name;
	}
	
	public void setDescription(String description){
		this.description = description;
	}
	
	public String getDescription(){
		return this.description;
	}
	
	public void setCategory(Category category){
		this.category = category;
	}
	
	public Category getCategory(){
		return this.category;
	}

	public void setStatus(Status status){
		this.status = status;
	}
	
	public Status getStatus(){
		return this.status;
	}
	
	public void setLocation(String location){
		this.location = location;
	}
	
	public String getLocation(){
		return this.location;
	}

	public boolean hasSelection(){
		if(selection.isEmpty()){
			return false;
		}
		
		return true;
	}
	
	public List<Integer> getSelection(){
		return selection;
	}
	
	public void setSelection(List<Integer> selection){
		this.selection = selection;
	}
	
	
	/**
	 * Print Event for Debugging purposes
	 */
	
	public boolean isDeadline() {
		if (this.category == Category.DEADLINE && this.status != Status.UNDETERMINED) {
			return true;
		}
		return false;
	}
	
	public boolean isEvent() {
		if (this.category == Category.EVENT && this.status != Status.UNDETERMINED) {
			return true;
		}
		return false;
	}
	
	public boolean isReservedEvent(){
		if (this.status == Status.UNDETERMINED && 
				this.category != Category.FLOATING){
			return true;
		}
		return false;
	}
	
	public String printEvent(){
		String result = new String("\n" + "Event name: " + this.name + "\n");
		result = result + "\t " + description + "\n";
		result = result + "\t Category: " + this.category + " Status: " + this.status + "\n";
		
		return result;

	}
	
}
```
###### /src/main/ReservedEvent.java
``` java
 */
public class ReservedEvent extends GenericEvent{
	private ArrayList<TimePair> reservedTimes;
	
	/**
	 * The Default Constructor for Reserved Event
	 */
	public ReservedEvent(){
		super();
		reservedTimes = new ArrayList<TimePair>();
	}
	
	/**
	 * Constructor which creates ReservedEvent using provided parameters
	 * @param name
	 * @param location
	 * @param description
	 * @param category
	 * @param reservedTimes
	 * @param status
	 */
	public ReservedEvent(String name, String location,String description,
			Category category, ArrayList<TimePair> reservedTimes, Status status){
		super(name, location, description, category, status);
		this.reservedTimes = reservedTimes;
		
	}

	/**
	 * Gets the ArrayList of all Reserved Times
	 * @return
	 */
	public ArrayList<TimePair> getReservedTimes(){
		return this.reservedTimes;
	}
	
	/**
	 * Assigns the provided ArrayList to the ArrayList of Reserved Times
	 * @param reservedTimes
	 */
	public void setReservedTimes(ArrayList<TimePair> reservedTimes){
		this.reservedTimes = reservedTimes;
		
	}
	
	/**
	 * Gets an exact copy of the ReservedEvent
	 * @return
	 */
	public ReservedEvent getClone(){
		ReservedEvent clonedEvent = new ReservedEvent(this.getName(), this.getLocation(),
				this.getDescription(), this.getCategory(), this.getReservedTimes(), this.getStatus());
		
		return clonedEvent;
	}
	
}
```
###### /src/main/State.java
``` java
 */
public class State {
	public static final String MESSAGE_EVENT_NOT_FOUND = "The requested event was not found";
	public static final String MESSAGE_PARSE_ERROR = "Unable to process the requested event";
	public static final String MESSAGE_TOO_MANY_SELECTIONS = "More than one result was found. Please select the desired event's number";
	public static final String MESSAGE_NO_SELECTED_EVENT = "No event has been selected. Please select an event.";
	public static final String MESSAGE_INVALID_INDEX = "Please select a valid index";
	public static final String MESSAGE_ATTEMPTED_ADD_WITH_RESERVE = "Cannot create floating event using reserve. Please use the Add command";
	public static final String MESSAGE_ATTEMPTED_RESERVE_WITH_ADD = "Cannot create reserved event using add. Please use the Reserve command";
	public static final String MESSAGE_INVALID_RESERVED = "Cannot use Reserve for this type";
	public static final String MESSAGE_INVALID_CONFIRM = "Cannot use confirm an event that is not a reserved type";
	public static final String MESSAGE_WELCOME = "Welcome to Supahotfire's task manager";
	public static final String MESSAGE_COMPLETE_INVALID_EVENT_TYPE = "You cannot complete a reserved or floating event";
	public static final String MESSAGE_COMPLETE_INVALID_EVENT_STATUS = "You can only complete events with the status incomplete";

	public static final int NO_EVENTS_SELECTED = 0;
	public static final int ONE_EVENT_SELECTED = 1;
	public static final int MULTIPLE_EVENTS_SELECTED = 2;
	
	public ArrayList<Event> completedEvents;
	public ArrayList<Event> incompletedEvents;
	//Floating events
	public ArrayList<ReservedEvent> undeterminedEvents;
	//Events with multiple times
	public ArrayList<ReservedEvent> reservedEvents;
	
	
	/**Need to implements- selecting of individual types*/
	/*Type is generic for easy access in the UI*/
	public ArrayList<GenericEvent> undeterminedSelected;
	public ArrayList<GenericEvent> completedSelected;
	public ArrayList<GenericEvent> incompletedSelected;
	public GenericEvent filteredSelectedEvent;
	
	public ArrayList<GenericEvent> displayedEvents;
	public ArrayList<GenericEvent> selectedEvents;
	public Stack<State> eventHistory;
	
	public boolean hasErrorMessage;
	public GenericEvent selectedEvent;
	
	
	//indicates whether an event is selected and if more than one is selected
	public int selectionStatus;
	public int filterStatus;
	public Status tabStatus;
	
	public String statusMessage;

	/**
	 * CompleteState constructor initializes all Event Lists
	 */
	public State(){
		completedEvents = new ArrayList<Event>();
		incompletedEvents = new ArrayList<Event>();
		undeterminedEvents = new ArrayList<ReservedEvent>();
		reservedEvents = new ArrayList<ReservedEvent>(); 
		
		displayedEvents = new ArrayList<GenericEvent>();
		selectedEvents = new ArrayList<GenericEvent>();
		
		
		//Arrays for selected tabs of each kind of event
		undeterminedSelected = new ArrayList<GenericEvent>();
		completedSelected = new ArrayList<GenericEvent>();
		incompletedSelected = new ArrayList<GenericEvent>();
		
		
		eventHistory = new Stack<State>();
		
		statusMessage = new String();
		setStatusMessage(MESSAGE_WELCOME);
		hasErrorMessage = false;
		
		tabStatus = Constant.TAB_INCOMPLETE;

	}
	
	/**
	 * Constructs a State which is a clone of the state parameter passed to the constructor
	 * @param anotherState
	 */
	public State(State anotherState){
		completedEvents = cloneEventArray(anotherState.getCompletedList());
		incompletedEvents = cloneEventArray(anotherState.getIncompletedList());
		//Floating events
		undeterminedEvents = cloneReservedEventArray(anotherState.getUndeterminedList());
		//Events with multiple times
		reservedEvents = cloneReservedEventArray(anotherState.getReservedList());
		
		
		/**Need to implements- selecting of individual types*/
		/*Type is generic for easy access in the UI*/
		undeterminedSelected = cloneGenericEventArray(anotherState.getUndeterminedSelectedList());
		completedSelected = cloneGenericEventArray(anotherState.getCompletedSelectedList());
		incompletedSelected = cloneGenericEventArray(anotherState.getIncompletedSelectedList());
		filteredSelectedEvent = anotherState.getSingleFilteredEvent();
		
		displayedEvents = cloneGenericEventArray(anotherState.getDisplayedEvents());
		selectedEvents = cloneGenericEventArray(anotherState.getAllSelectedEvents());
		eventHistory = anotherState.eventHistory;
		
		hasErrorMessage = anotherState.hasErrorMessage;
		selectedEvent = anotherState.getSingleSelectedEvent();
		
		
		//indicates whether an event is selected and if more than one is selected
	    selectionStatus = anotherState.selectionStatus;
		filterStatus = anotherState.filterStatus;
		tabStatus = anotherState.tabStatus;
		
		statusMessage = anotherState.statusMessage;
	}
	
	/**
	 * Creates an exact clone of the ReservedEvent arrayList provided. 
	 * @param arrayList
	 * @return cloned ReservedEvent arrayList
	 */
	public ArrayList<ReservedEvent> cloneReservedEventArray(ArrayList<ReservedEvent> arrayList){
		ArrayList<ReservedEvent> newArray = new ArrayList<ReservedEvent>();
		for(ReservedEvent e: arrayList){
				newArray.add(e.getClone());
		}		
		return newArray;		
	}
	
	/**
	 * Creates an exact clone of the Event arrayList provided. 
	 * @param arrayList
	 * @return cloned Event arrayList
	 */
	public ArrayList<Event> cloneEventArray(ArrayList<Event> arrayList){
		ArrayList<Event> newArray = new ArrayList<Event>();
		for(Event e: arrayList){
				newArray.add(e.getClone());
		}		
		return newArray;		
	}
		
	/**
	 * Creates an exact clone of the GenericEvent arrayList provided. 
	 * @param arrayList
	 * @return cloned GenericEvent arrayList
	 */
	public ArrayList<GenericEvent> cloneGenericEventArray(ArrayList<GenericEvent> arrayList){
		ArrayList<GenericEvent> newArray = new ArrayList<GenericEvent>();
		for(GenericEvent e: arrayList){
			if(e instanceof ReservedEvent){
				newArray.add( ((ReservedEvent)e).getClone());
			}
			if(e instanceof Event){
				newArray.add( ((Event)e).getClone());
			}
		}		
		return newArray;		
	}
	
	/**
	 * Gets the singular selected event
	 * @return Current selected event. Null will be returned if more than one or no events are selected.
	 */
	public GenericEvent getSingleSelectedEvent(){
		return selectedEvent;			
	}
	
	/**
	 * Gets list of all the selected events.
	 * @return Current list of selected events. The list will be empty if no events are selected
	 */
	public ArrayList<GenericEvent> getAllSelectedEvents(){
		return selectedEvents;
	}

	
	/**
	 * Gets the singular selected event filtered by the status tab
	 * @return Current filtered event. Null will be returned if more than one or no events are selected through the status tab filter.
	 */
	public GenericEvent getSingleFilteredEvent(){
		return filteredSelectedEvent;

	}
	
	/**
	 * Gets list of all the selected events filtered by the status tab
	 * @return Current list of filtered events. The list will be empty if no events are selected through the status tab filter
	 */
	public ArrayList<GenericEvent> getAllFilteredEvents(){
		filterListsByTab();
		switch (tabStatus){
			case COMPLETE:
				return completedSelected;
			case INCOMPLETE:
				return incompletedSelected;
			case UNDETERMINED:
				return undeterminedSelected;				
			default:
				return null;
		
		}
	}

	/**
	 * Updates the filter lists based on current selected Events
	 */
	public void filterListsByTab(){
		clearFilterArrays();
		
		for(GenericEvent e: selectedEvents){
			filterComplete(e);
			filterIncomplete(e);
			filterUndetermined(e);
		}
		
	}

	/**
	 * Adds an event to the completed filter list
	 * @param e the event to be added
	 */
	private void filterComplete(GenericEvent e) {
		if(e.getStatus().equals(Status.COMPLETE)){
			completedSelected.add(e);
		}
	}
	
	/**
	 * Adds an event to the incomplete filter list
	 * @param e the event to be added
	 */
	private void filterIncomplete(GenericEvent e) {
		if(e.getStatus().equals(Status.INCOMPLETE)){
			incompletedSelected.add(e);
		}
	}
	
	/**
	 * Adds an event to the undetermined filter list
	 * @param e the event to be added
	 */
	private void filterUndetermined(GenericEvent e){
		if(e.getStatus().equals(Status.UNDETERMINED)){
			undeterminedSelected.add(e);
		}
	}
	
	/**
	 * Clear all filter arrays
	 */
	private void clearFilterArrays(){
		completedSelected.clear();
		incompletedSelected.clear();
		undeterminedSelected.clear();
	}
	
	/**
	 * Clears the state selection
	 */
	public void clearSelections(){
		if(!selectedEvents.isEmpty()){
			selectedEvents.clear();
		}
		selectedEvent = null;
		filteredSelectedEvent = null;
		clearFilterArrays();
		setSelectionStatus(NO_EVENTS_SELECTED);
		setFilterStatus(NO_EVENTS_SELECTED);;

	}
	
	/**
	 * Gets the status of the selected tab
	 * @return
	 */
	public Status getSelectedTab(){
		return tabStatus;
	}
	
	/**
	 * Sets the status of the selected tab
	 * @param tabStatus the new tab status
	 */
	public void setSelectedTab(Status tabStatus){
		this.tabStatus = tabStatus;
	}
	
	/**
	 * Returns whether or not the tab is currently COMPLETE
	 * @return
	 */
	public boolean isCompletedSelected(){
		return tabStatus == Constant.TAB_COMPLETE;
	}
	
	/**
	 * Returns whether or not the tab is currently INCOMPLETE
	 * @return
	 */
	public boolean isIncompletedSelected(){
		return tabStatus == Constant.TAB_INCOMPLETE;
	}
	
	/**
	 * Returns whether or not the tab is currently UNDETERMINED
	 * @return
	 */
	public boolean isUndeterminedSelected(){
		return tabStatus == Constant.TAB_UNDETERMINED;
	}
	
	public boolean hasEventSelected () {
		return selectionStatus != NO_EVENTS_SELECTED;
	}
	
	public boolean hasSingleEventSelected () {
		return selectionStatus == ONE_EVENT_SELECTED;
	}
	
	public boolean hasMultipleEventSelected () {
		return selectionStatus == MULTIPLE_EVENTS_SELECTED;
	}
	
	public boolean hasEventFiltered () {
		return filterStatus != NO_EVENTS_SELECTED;
	}
	
	public boolean hasSingleEventFiltered () {
		boolean retValue =  filterStatus == ONE_EVENT_SELECTED;
		if(retValue){
			return retValue;
		}
		switch (tabStatus){
			case COMPLETE:
				if(completedSelected.size() == 1){
						filteredSelectedEvent = completedSelected.get(0); 
						retValue = true;
				}
				break;
			case INCOMPLETE:
				if(incompletedSelected.size() == 1){
					filteredSelectedEvent = incompletedSelected.get(0);
					retValue = true;
				}
				break;			
			case UNDETERMINED:
				if(undeterminedSelected.size() == 1){
					filteredSelectedEvent = undeterminedSelected.get(0);
					retValue = true;
				}
				break;
		}
		
		return retValue;
				
	}
	
	public boolean hasMultipleEventFiltered () {
		return filterStatus == MULTIPLE_EVENTS_SELECTED;
	}
	
	public void setOneSelectedEvent(GenericEvent event){
		clearSelections();
		addToSelectedEvents(event);
		selectedEvent = event;
		filteredSelectedEvent = event;
		setSelectionStatus(ONE_EVENT_SELECTED);
		setFilterStatus(ONE_EVENT_SELECTED);

	}
	
	public void addToSelectedEvents(GenericEvent event){
		selectedEvents.add(event);
	}
	
	public int getFilterStatus(){
		return filterStatus;
	}
	
	public void setFilterStatus(int filterStatus){
		if(filterStatus > 2){
			filterStatus = 2;
		}
		this.filterStatus = filterStatus;
	}
	
	public int getSelectionStatus(){
		return selectionStatus;
	}
	
	public void setSelectionStatus(int selectionStatus){
		this.selectionStatus = selectionStatus;
	}
	
	public void setStatusMessage(String statusMessage){
		this.statusMessage = statusMessage;
	}
	
	public void setErrorMessage(String statusMessage){
		this.hasErrorMessage = true;
		this.statusMessage = statusMessage;
	}
	
	public void clearStatusMessage(){
		this.statusMessage = null;
		hasErrorMessage = false;
	}
	
	public String getStatusMessage(){
		return statusMessage;
	}
	
	public ArrayList<GenericEvent> getAllEvents(){
		ArrayList<GenericEvent> allEvents = new ArrayList<GenericEvent>();
		allEvents.addAll(completedEvents);
		allEvents.addAll(incompletedEvents);
		allEvents.addAll(undeterminedEvents);
		allEvents.addAll(reservedEvents);
		
		return allEvents;
	}
	
	public  void addToCompletedList(Event event){
		completedEvents.add(event);
	}
	
	public  void addToIncompletedList(Event event){
		incompletedEvents.add(event);
	}
	
	public  void addToUndeterminedList(ReservedEvent event){
		undeterminedEvents.add(event);
	}
	
	public  void addToReservedList(ReservedEvent event){
		reservedEvents.add(event);
	}
	

	public  ArrayList<Event> getCompletedList(){
		return completedEvents;
	}
	
	public  ArrayList<Event> getIncompletedList(){
		return incompletedEvents;
	}
	
	public  ArrayList<ReservedEvent> getUndeterminedList(){
		return undeterminedEvents;
	}
	
	public  ArrayList<ReservedEvent> getReservedList(){
		return reservedEvents;
	}
	
	public  ArrayList<ReservedEvent> getFloatingList(){
		return undeterminedEvents;
	}
	
	public  ArrayList<GenericEvent> getCompletedSelectedList(){
		return completedSelected;
	}
	
	public  ArrayList<GenericEvent> getIncompletedSelectedList(){
		return incompletedSelected;
	}
	
	public  ArrayList<GenericEvent> getUndeterminedSelectedList(){
		return undeterminedSelected;
	}
	
	public  ArrayList<GenericEvent> getDisplayedEvents(){
		return displayedEvents;
	}
	
	public void updateDisplayedEvents(){
		displayedEvents.clear();
		displayedEvents.addAll(completedEvents);
		displayedEvents.addAll(incompletedEvents);
		displayedEvents.addAll(reservedEvents);		
	}
 
	

}



```
###### /src/main/TimePair.java
``` java
 */
public class TimePair {
	private Date startTime;
	private Date endTime;
	private String stringStartTime;
	private String stringEndTime;
	
	/**
	 * TimePair constructor which takes in  a startTime and an endTime
	 * @param startTime
	 * @param endTime
	 */
	public TimePair(Date startTime, Date endTime){
		this.startTime = startTime;
		this.endTime = endTime;
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		    
		if(startTime == Constant.MIN_DATE){
			Calendar cal = Calendar.getInstance(); 
			cal.setTime(endTime); 
			cal.add(Calendar.HOUR_OF_DAY, -1); 
			this.startTime = cal.getTime(); 	
			this.stringStartTime = "";
		} else{
			this.stringStartTime = sdf.format(startTime);
		}
		
		if(endTime == Constant.MAX_DATE){
			this.stringEndTime = "";
		} else{
			this.stringEndTime = sdf.format(endTime);
		}
	}

	public Date getStartTime(){
		return this.startTime;
	}
	
	public void setStartTime(Date startTime){
		if(startTime == Constant.MIN_DATE){
			Calendar cal = Calendar.getInstance(); 
			cal.setTime(endTime); 
			cal.add(Calendar.HOUR_OF_DAY, -1); 
			this.startTime = cal.getTime(); 
			this.stringStartTime = "";
		} else{
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
			this.stringStartTime = sdf.format(startTime);
		}
		this.startTime = startTime;
	}
		
	public Date getEndTime(){
		return this.endTime;
	}
	
	public void setEndTime(Date endTime){
		if(endTime == Constant.MAX_DATE){
			this.stringEndTime = "";
		} else{
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
			this.stringEndTime = sdf.format(endTime);
		}
		this.endTime = endTime;
	}
	
	public String getStartTimeString(){
		return stringStartTime;
	}
	
	public String getEndTimeString(){
		return stringEndTime;
	}
}

```
